<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÏõîÎ†õ ÎåÄÏãúÎ≥¥Îìú</title>
    <script src="https://cdn.jsdelivr.net/npm/web3@1.10.0/dist/web3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.17.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.17.1/firebase-database-compat.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/@solana/web3.js@latest/lib/index.iife.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            background: #1a1f2e;
            color: #fff;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: clamp(1.5em, 5vw, 2.5em);
            margin-bottom: 10px;
        }

        .search-section {
            background: #232937;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .search-row {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .chain-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 5px;
        }

        .chain-badge.eth { background: #627EEA; }
        .chain-badge.bsc { background: #F3BA2F; color: #000; }
        .chain-badge.polygon { background: #8247E5; }
        .chain-badge.arbitrum { background: #28A0F0; }
        .chain-badge.optimism { background: #FF0420; }
        .chain-badge.avalanche { background: #E84142; }

        select {
            background: #1a1f2e;
            color: white;
            border: 1px solid #444;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            min-width: 180px;
        }

        input {
            flex: 1;
            background: #1a1f2e;
            color: white;
            border: 1px solid #444;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 16px;
        }

        button {
            background: #3b4252;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        button:hover {
            background: #4c5565;
        }

        button:disabled {
            background: #666;
            cursor: not-allowed;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .info-card {
            background: #2e3545;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .info-card.blue {
            background: #3b4863;
        }

        .info-card.green {
            background: #2e4a3e;
        }

        .info-label {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 18px;
            font-weight: bold;
        }

        .stats-section {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: #232937;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-label {
            font-size: 16px;
            color: #aaa;
            margin-bottom: 10px;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
        }

        .chart-section {
            display: grid;
            grid-template-columns: 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .table-container {
            background: #232937;
            padding: 20px;
            border-radius: 15px;
            overflow-x: auto;
            max-width: 100%;
            margin-bottom: 30px;
        }

        .chart-container {
            background: #232937;
            padding: 20px;
            border-radius: 15px;
            position: relative;
            height: 500px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            min-width: 900px;
        }

        th, td {
            padding: 12px 8px;
            text-align: left;
            border-bottom: 1px solid #444;
            word-break: break-word;
        }

        th:nth-child(1), td:nth-child(1) { width: 50px; text-align: center; }
        th:nth-child(2), td:nth-child(2) { width: 150px; }
        th:nth-child(3), td:nth-child(3) {
            width: 400px;
            font-size: 12px;
            font-family: monospace;
            word-break: break-all;
        }
        th:nth-child(4), td:nth-child(4) { width: 120px; text-align: right; font-weight: bold; }
        th:nth-child(5), td:nth-child(5) { width: 180px; text-align: left; font-size: 11px; }
        th:nth-child(6), td:nth-child(6) { width: 80px; text-align: center; font-size: 11px; color: #aaa; }
        th:nth-child(7), td:nth-child(7) { width: 100px; text-align: center; }

        th {
            background: #2e3545;
            font-weight: bold;
        }

        tr:hover {
            background: #2e3545;
        }

        .address-clickable {
            cursor: pointer;
            transition: all 0.2s;
            padding: 4px 8px;
            border-radius: 4px;
            position: relative;
        }

        .address-clickable:hover {
            background: #3b4863;
            color: #4CAF50;
        }

        .address-clickable:active {
            transform: scale(0.98);
        }

        .copy-tooltip {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: #4CAF50;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 1000;
        }

        .copy-tooltip.show {
            opacity: 1;
        }

        .explorer-btn {
            background: #4CAF50;
            color: white !important;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            white-space: nowrap;
            transition: all 0.2s;
            min-width: 70px;
            justify-content: center;
        }

        .explorer-btn:hover {
            background: #45a049;
            transform: translateY(-1px);
        }

        .explorer-btn::before {
            content: "üîó";
            font-size: 11px;
        }

        .address-cell {
            position: relative;
        }

        .wallet-manager {
            background: #2e3545;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            margin-top: 40px;
        }

        .wallet-manager-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            cursor: pointer;
        }

        .wallet-manager-header h3 {
            margin: 0;
        }

        .toggle-icon {
            font-size: 20px;
            transition: transform 0.3s;
        }

        .toggle-icon.collapsed {
            transform: rotate(-90deg);
        }

        .wallet-manager-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .wallet-manager-content.collapsed {
            max-height: 0;
        }

        .wallet-form {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .wallet-list {
            max-height: 200px;
            overflow-y: auto;
            background: #1a1f2e;
            padding: 10px;
            border-radius: 8px;
        }

        .wallet-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin-bottom: 5px;
            background: #232937;
            border-radius: 5px;
            font-size: 12px;
        }

        .wallet-item span {
            word-break: break-all;
            flex: 1;
            margin-right: 10px;
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
        }

        .wallet-actions {
            display: flex;
            gap: 5px;
        }

        .edit-btn {
            background: #2196F3;
            padding: 5px 10px;
            font-size: 12px;
        }

        .edit-btn:hover {
            background: #1976D2;
        }

        .delete-btn {
            background: #d32f2f;
            padding: 5px 10px;
            font-size: 12px;
        }

        .delete-btn:hover {
            background: #f44336;
        }

        .loading {
            text-align: center;
            padding: 20px;
            color: #888;
        }

        .error {
            background: #d32f2f;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .warning {
            background: #ff9800;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
            color: #000;
        }

        .success {
            background: #4CAF50;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }

        .progress-bar {
            background: #1a1f2e;
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }

        .progress-fill {
            background: #4CAF50;
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }

        .detailed-progress {
            background: #232937;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .progress-step {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px;
            background: #2e3545;
            border-radius: 5px;
        }

        .progress-step.active {
            background: #4CAF50;
        }

        .progress-step.completed {
            background: #2e4a3e;
        }

        .progress-step.error {
            background: #d32f2f;
        }

        .searching-indicator {
            display: inline-block;
            color: #ff9800;
            font-weight: bold;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        #chartCanvas {
            max-width: 100%;
            max-height: 350px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.connected {
            background: #4CAF50;
        }

        .status-indicator.disconnected {
            background: #d32f2f;
        }

        .status-indicator.connecting {
            background: #ff9800;
            animation: pulse 1s infinite;
        }

        .rpc-status {
            background: #2e3545;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 12px;
            color: #aaa;
        }

        .rpc-status.success {
            background: #2e4a3e;
            color: #4CAF50;
        }

        @media (max-width: 768px) {
            .table-container {
                padding: 10px;
            }

            table {
                min-width: 800px;
            }

            th, td {
                padding: 8px 4px;
                font-size: 12px;
            }

            .explorer-btn {
                padding: 6px 8px;
                font-size: 11px;
                min-width: 60px;
            }

            th:nth-child(3), td:nth-child(3) {
                width: 350px;
                font-size: 11px;
            }
        }

        .array-warning {
            background: #ff9800;
            color: #000;
            padding: 10px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .fix-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 12px;
        }

        .fix-button:hover {
            background: #45a049;
        }

        /* Ï∂úÍ∏à Ï∂îÏ†Å Ïä§ÌÉÄÏùº */
        .withdrawal-cell {
            position: relative;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .withdrawal-main {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .withdrawal-amount-big {
            color: #FFA726;
            font-weight: 600;
            font-size: 15px;
            letter-spacing: 0.3px;
        }

        .withdrawal-count {
            color: #4CAF50;
            cursor: pointer;
            font-size: 11px;
            padding: 2px 6px;
            background: #2e4a3e;
            border-radius: 10px;
            user-select: none;
            transition: all 0.2s;
        }

        .withdrawal-count:hover {
            background: #3d5f4d;
            color: #66BB6A;
        }

        .withdrawal-tx-link {
            color: #888;
            text-decoration: none;
            font-size: 10px;
            font-family: monospace;
            transition: all 0.2s;
        }

        .withdrawal-tx-link:hover {
            color: #4CAF50;
        }

        .withdrawal-link {
            color: #4CAF50;
            text-decoration: none;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-block;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .withdrawal-link:hover {
            background: #2e4a3e;
            color: #66BB6A;
        }

        .withdrawal-amount {
            color: #ff9800;
            font-weight: bold;
            margin-right: 4px;
        }

        .withdrawal-loading {
            color: #888;
            font-size: 10px;
            animation: pulse 1.5s infinite;
        }

        .withdrawal-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: #1a1f2e;
            border: 1px solid #4CAF50;
            border-radius: 6px;
            padding: 8px;
            z-index: 1000;
            min-width: 250px;
            max-height: 300px;
            overflow-y: auto;
            box-shadow: 0 4px 12px rgba(0,0,0,0.5);
            display: none;
        }

        .withdrawal-dropdown.show {
            display: block;
        }

        .withdrawal-item {
            padding: 10px;
            margin-bottom: 6px;
            background: #232937;
            border-radius: 6px;
            border-left: 3px solid #4CAF50;
            transition: all 0.2s;
        }

        .withdrawal-item:last-child {
            margin-bottom: 0;
        }

        .withdrawal-item:hover {
            background: #2e3545;
            border-left-color: #66BB6A;
        }

        .withdrawal-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .withdrawal-item-amount {
            color: #FFA726;
            font-weight: 600;
            font-size: 14px;
        }

        .withdrawal-item-time {
            color: #4CAF50;
            font-size: 10px;
            background: #2e4a3e;
            padding: 2px 6px;
            border-radius: 8px;
        }

        .withdrawal-item-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
        }

        .withdrawal-item-to {
            color: #888;
            font-family: monospace;
        }

        .withdrawal-item-link {
            color: #4CAF50;
            text-decoration: none;
            padding: 2px 8px;
            background: #2e4a3e;
            border-radius: 4px;
            font-size: 10px;
            transition: all 0.2s;
        }

        .withdrawal-item-link:hover {
            background: #3d5f4d;
            color: #66BB6A;
        }

        .withdrawal-toggle {
            color: #4CAF50;
            cursor: pointer;
            margin-left: 4px;
            font-size: 10px;
            user-select: none;
        }

        .withdrawal-toggle:hover {
            color: #66BB6A;
        }

        .time-badge {
            display: inline-block;
            padding: 2px 6px;
            background: #2e3545;
            border-radius: 8px;
            font-size: 10px;
            color: #aaa;
            white-space: nowrap;
        }

        .time-badge.recent {
            background: #2e4a3e;
            color: #4CAF50;
        }

        @media (max-width: 768px) {
            th:nth-child(5), td:nth-child(5) {
                width: 150px;
                font-size: 10px;
            }
            th:nth-child(6), td:nth-child(6) {
                width: 70px;
                font-size: 10px;
            }
        }

        /* Î°úÍ∑∏ Ï∞Ω Ïä§ÌÉÄÏùº */
        .log-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 500px;
            max-height: 400px;
            background: #1a1f2e;
            border: 2px solid #3b4252;
            border-radius: 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 9999;
            display: flex;
            flex-direction: column;
        }

        .log-header {
            background: #3b4252;
            padding: 10px 15px;
            border-radius: 6px 6px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }

        .log-header h3 {
            font-size: 14px;
            margin: 0;
        }

        .log-controls {
            display: flex;
            gap: 10px;
        }

        .log-btn {
            background: #232937;
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .log-btn:hover {
            background: #2a3141;
        }

        .log-content {
            padding: 10px;
            overflow-y: auto;
            flex: 1;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            line-height: 1.4;
        }

        .log-entry {
            padding: 4px 0;
            border-bottom: 1px solid #232937;
        }

        .log-entry:last-child {
            border-bottom: none;
        }

        .log-time {
            color: #888;
            margin-right: 8px;
        }

        .log-error { color: #ff6b6b; }
        .log-warn { color: #ffd93d; }
        .log-success { color: #6bcf7f; }
        .log-info { color: #4dabf7; }
        .log-websocket { color: #a78bfa; }

        .log-panel.minimized .log-content {
            display: none;
        }

        .log-panel.minimized {
            max-height: 50px;
        }

        @media (max-width: 768px) {
            .log-panel {
                width: calc(100% - 40px);
                right: 20px;
                left: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ÏõîÎ†õ ÎåÄÏãúÎ≥¥Îìú</h1>
            <div id="connectionStatus" style="margin-top: 10px;">
                <span class="status-indicator connected"></span>
                <span id="statusText">ÏãúÏä§ÌÖú Ï§ÄÎπÑ ÏôÑÎ£å!</span>
            </div>
            <div id="rpcStatus" class="rpc-status" style="display: none;">
                ÌòÑÏû¨ RPC ÏÑúÎ≤Ñ: Ïó∞Í≤∞ ÎåÄÍ∏∞Ï§ë...
            </div>
        </div>

        <div id="arrayWarning" class="array-warning" style="display: none;">
            ‚ö†Ô∏è ÏùºÎ∂Ä ÏßÄÍ∞ë Ï£ºÏÜåÍ∞Ä Î∞∞Ïó¥ ÌòïÌÉúÎ°ú Ï†ÄÏû•ÎêòÏñ¥ ÏûàÏäµÎãàÎã§.
            <button class="fix-button" onclick="fixArrayAddresses()">ÏûêÎèô ÏàòÏ†ï</button>
        </div>

        <div class="search-section">
            <div class="search-row">
                <label><strong>Ï≤¥Ïù∏ ÏÑ†ÌÉù:</strong></label>
            </div>
            <div class="search-row">
                <select id="chainSelect">
                    <option value="ETH">ETH</option>
                    <option value="Base">Base</option>
                    <option value="BSC">BSC</option>
                    <option value="Polygon">Polygon</option>
                    <option value="Arbitrum">Arbitrum</option>
                    <option value="Optimism">Optimism</option>
                    <option value="Avalanche">Avalanche</option>
                    <option value="SOL">SOL</option>
                </select>
                <select id="regionSelect">
                    <option value="ALL">ALL</option>
                    <option value="FOREIGN" selected>FOREIGN</option>
                    <option value="DOMESTIC">DOMESTIC</option>
                </select>
                <input type="text" id="tokenInput" placeholder="ÌÜ†ÌÅ∞ Ïª®Ìä∏ÎûôÌä∏ Ï£ºÏÜå (0x...) ÎòêÎäî ÎÑ§Ïù¥Ìã∞Î∏å ÌÜ†ÌÅ∞Î™Ö (ETH, BNB, SOL Îì±)">
                <button id="searchBtn">üîç Ï°∞Ìöå</button>
            </div>
        </div>

        <div id="detailedProgress" class="detailed-progress" style="display: none;">
            <h4>üîÑ Í≤ÄÏÉâ ÏßÑÌñâ ÏÉÅÌô©</h4>
            <div class="progress-step" id="step1">
                <span>1. Î∏îÎ°ùÏ≤¥Ïù∏ Ïó∞Í≤∞</span>
                <span>‚è≥</span>
            </div>
            <div class="progress-step" id="step2">
                <span>2. ÌÜ†ÌÅ∞ Ï†ïÎ≥¥ Ï°∞Ìöå</span>
                <span>‚è≥</span>
            </div>
            <div class="progress-step" id="step3">
                <span>3. Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï°∞Ìöå</span>
                <span>‚è≥</span>
            </div>
            <div class="progress-step" id="step4">
                <span>4. ÏßÄÍ∞ë ÏûîÍ≥† Ï°∞Ìöå</span>
                <span>‚è≥</span>
            </div>
        </div>

        <div id="results" style="display: none;">
            <div class="info-grid">
                <div class="info-card">
                    <div class="info-label">ÌÜ†ÌÅ∞ Ïù¥Î¶Ñ:</div>
                    <div class="info-value" id="tokenName">-</div>
                </div>
                <div class="info-card">
                    <div class="info-label">Ïã¨Î≥º:</div>
                    <div class="info-value" id="tokenSymbol">-</div>
                </div>
                <div class="info-card blue">
                    <div class="info-label">Ï≤¥Ïù∏:</div>
                    <div class="info-value" id="currentChainDisplay">-</div>
                </div>
                <div class="info-card blue">
                    <div class="info-label">Ïª®Ìä∏ÎûôÌä∏:</div>
                    <div class="info-value" id="contractAddress" style="font-size: 10px; word-break: break-all;">-</div>
                </div>
            </div>

            <div class="info-grid">
                <div class="info-card green">
                    <div class="info-label">ÌÜ†ÌÅ∞ Í∞ÄÍ≤©:</div>
                    <div class="info-value" id="tokenPrice">-</div>
                </div>
                <div class="info-card green">
                    <div class="info-label">24h Î≥ÄÎèô:</div>
                    <div class="info-value" id="priceChange">-</div>
                </div>
                <div class="info-card green">
                    <div class="info-label">Market Cap:</div>
                    <div class="info-value" id="marketCap">-</div>
                </div>
                <div class="info-card green">
                    <div class="info-label">FDV:</div>
                    <div class="info-value" id="fdv">-</div>
                </div>
            </div>

            <div id="progressSection" style="display: none; margin-bottom: 20px;">
                <div class="loading">
                    <span id="progressText">ÏßÄÍ∞ë Ï°∞Ìöå Ï§ë... (0/0)</span>
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                </div>
            </div>

            <div class="stats-section">
                <div class="stat-card">
                    <div class="stat-label">Ï¥ù ÏûîÍ≥†</div>
                    <div class="stat-value" id="totalBalance">0</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Ï¥ù Îã¨Îü¨ Í∞ÄÏπò</div>
                    <div class="stat-value" id="totalValue">$0</div>
                </div>
            </div>

            <div class="chart-section">
                <div class="table-container">
                    <h3>üìã Exchange Status</h3>
                    <div style="overflow-x: auto;">
                        <table id="exchangeTable">
                            <thead>
                                <tr>
                                    <th>No.</th>
                                    <th>Exchange</th>
                                    <th>Address</th>
                                    <th>Balance</th>
                                    <th>Last Withdrawal</th>
                                    <th>Time</th>
                                    <th>Explorer</th>
                                </tr>
                            </thead>
                            <tbody id="tableBody">
                            </tbody>
                        </table>
                    </div>
                </div>

                <div class="chart-container">
                    <canvas id="chartCanvas" style="max-height: 450px;"></canvas>
                </div>
            </div>
        </div>

        <div class="wallet-manager">
            <div class="wallet-manager-header" onclick="toggleWalletManager()">
                <h3>Í±∞ÎûòÏÜå ÏßÄÍ∞ë Í¥ÄÎ¶¨</h3>
                <span class="toggle-icon" id="walletToggleIcon">‚ñº</span>
            </div>
            <div class="wallet-manager-content" id="walletManagerContent">
                <div class="wallet-form">
                    <select id="walletChainType" style="min-width: 80px;">
                        <option value="EVM">EVM</option>
                        <option value="SOL">SOL</option>
                    </select>
                    <input type="text" id="walletName" placeholder="Í±∞ÎûòÏÜåÎ™Ö (Ïòà: Binance_Hot)">
                    <input type="text" id="walletAddress" placeholder="ÏßÄÍ∞ë Ï£ºÏÜå">
                    <select id="walletRegion" style="min-width: 100px;">
                        <option value="FOREIGN">Ìï¥Ïô∏</option>
                        <option value="DOMESTIC">Íµ≠ÎÇ¥</option>
                    </select>
                    <button id="walletActionBtn">Ï∂îÍ∞Ä</button>
                    <button id="walletCancelBtn" style="display: none; background: #666;">Ï∑®ÏÜå</button>
                </div>

                <div class="wallet-list" id="walletList"></div>

                <div style="margin: 15px 0 0 0;">
                    <div onclick="toggleCSVUpload()" style="cursor: pointer; display: flex; align-items: center; gap: 8px; padding: 8px; background: #2e3545; border-radius: 5px; font-size: 13px;">
                        <span id="csvToggleIcon" style="transition: transform 0.3s;">üìÅ</span>
                        <span style="color: #aaa;">ÌååÏùº ÏóÖÎ°úÎìú (CSV/XLSX)</span>
                    </div>
                    <div id="csvUploadContent" style="max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out;">
                        <div style="margin-top: 10px; padding: 12px; background: #1a1f2e; border-radius: 8px; border: 1px solid #444;">
                            <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                                ÌòïÏãù: name, address, region Ïª¨Îüº ÌïÑÏàò
                            </p>

                            <div style="display: flex; gap: 10px; align-items: flex-start; flex-wrap: wrap; margin-bottom: 12px;">
                                <input type="file" id="csvFile" accept=".csv,.xlsx" style="background: #2e3545; padding: 6px; border-radius: 4px; border: 1px solid #444; color: white; font-size: 12px; flex: 1; min-width: 200px;">

                                <div style="display: flex; align-items: center; gap: 6px; padding: 6px 10px; background: #2e3545; border-radius: 4px; border: 1px solid #444; white-space: nowrap;">
                                    <input type="checkbox" id="replaceMode" style="accent-color: #f44336;">
                                    <label for="replaceMode" style="font-size: 12px; color: #f44336; cursor: pointer; font-weight: bold;">Ï†ÑÏ≤¥ ÍµêÏ≤¥</label>
                                </div>
                            </div>

                            <div style="margin-bottom: 12px; padding: 6px 8px; background: #2e3545; border-radius: 4px; font-size: 11px; color: #aaa; line-height: 1.3;">
                                <strong style="color: #f44336;">Ï†ÑÏ≤¥ ÍµêÏ≤¥:</strong> Í∏∞Ï°¥ ÏÇ≠Ï†ú ‚Üí ÌååÏùºÎ°ú ÎåÄÏ≤¥ &nbsp;&nbsp;
                                <strong style="color: #4CAF50;">Ï∂îÍ∞ÄÎßå:</strong> Í∏∞Ï°¥ Ïú†ÏßÄ + ÌååÏùº Ï∂îÍ∞Ä
                            </div>

                            <div style="display: flex; gap: 8px; align-items: center; flex-wrap: wrap; margin-bottom: 8px;">
                                <button onclick="uploadCSV()" style="background: #4CAF50; padding: 8px 16px; font-size: 12px; font-weight: bold;">üì§ ÏóÖÎ°úÎìú</button>
                                <button onclick="downloadTemplate()" style="background: #2196F3; padding: 8px 16px; font-size: 12px;">üìã ÌÖúÌîåÎ¶ø</button>
                            </div>
                            <div id="uploadStatus" style="font-size: 11px;"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="loading" class="loading" style="display: none;">
            Ï°∞Ìöå Ï§ë...
        </div>
        <div id="error" class="error" style="display: none;"></div>
        <div id="warning" class="warning" style="display: none;"></div>
        <div id="success" class="success" style="display: none;"></div>
    </div>

    <script>
        let wallets = {};
        let web3 = null;
        let chart = null;
        let isSearching = false;
        let currentChain = 'ETH';
        let database = null;
        let currentRpcUrl = '';
        let editingWallet = null;
        let currentTokenAddress = '';

        // RPC Ï∫êÏãú - Ï≤¥Ïù∏Î≥ÑÎ°ú ÏÑ±Í≥µÌïú RPCÎì§ Ï†ÄÏû•
        const rpcCache = {};
        const solConnectionCache = {};

        // Ï∂úÍ∏à Ï∂îÏ†Å Í¥ÄÎ†® Î≥ÄÏàò
        let wsConnection = null;
        let withdrawalCache = {};
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;

        // === Withdrawal polling (Top 10) ===
        // === Withdrawal Monitoring (Hybrid Mode) ===
        let withdrawalPollTimer = null;
        const WITHDRAWAL_POLL_INTERVAL_MS = 30 * 1000; // 30Ï¥à (Hybrid Î™®Îìú)
        const WITHDRAWAL_HISTORY_LIMIT = 10;
        let currentTokenDecimals = 18; // ERC20 decimals Ï∫êÏãú
        const blockTimestampCache = {}; // { [chain-blockNumber]: timestamp }
        const lastSeenWithdrawalTx = {}; // { [cacheKey]: txHash }
        let currentTop10Addresses = []; // ÌòÑÏû¨ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏù∏ Top 10 Ï£ºÏÜå
        let currentTop10Names = []; // ÌòÑÏû¨ Î™®ÎãàÌÑ∞ÎßÅ Ï§ëÏù∏ Top 10 Ïù¥Î¶Ñ
        let isWebSocketActive = false; // WebSocket ÌôúÏÑ± ÏÉÅÌÉú
        let isPollingActive = false; // Polling ÌôúÏÑ± ÏÉÅÌÉú

        const firebaseConfig = {
            apiKey: "AIzaSyA1YFZp_0W-FAnuRohEl-jqZ0uZvpKDLXM",
            authDomain: "wallets-24b29.firebaseapp.com",
            databaseURL: "https://wallets-24b29-default-rtdb.asia-southeast1.firebasedatabase.app/",
            projectId: "wallets-24b29",
            storageBucket: "wallets-24b29.firebasestorage.app",
            messagingSenderId: "150625886270",
            appId: "1:150625886270:web:ee5da3abe230994184b16f"
        };

        // üöÄ ÏµúÏ†ÅÌôîÎêú RPC ÏÑúÎ≤Ñ ÏÑ§Ï†ï (Îπ†Î•∏ ÏÑúÎ≤ÑÎßå ÏÑ†Î≥Ñ)
        const CHAIN_CONFIG = {
            'ETH': {
                name: 'Ethereum',
                explorer: 'https://etherscan.io',
                rpcs: [
                    'https://eth.llamarpc.com',
                    'https://ethereum.publicnode.com',
                    'https://cloudflare-eth.com',
                    'https://rpc.ankr.com/eth',
                    'https://eth-mainnet.public.blastapi.io',
                    'https://ethereum-rpc.publicnode.com',
                    'https://eth.drpc.org',
                    'https://eth.meowrpc.com',
                    'https://rpc.flashbots.net',
                    'https://1rpc.io/eth',
                    'https://ethereum.blockpi.network/v1/rpc/public',
                    'https://rpc.mevblocker.io',
                    'https://eth-pokt.nodies.app',
                    'https://rpc.payload.de',
                    'https://eth.merkle.io',
                    'https://api.securerpc.com/v1',
                    'https://singapore.rpc.blxrbdn.com',
                    'https://virginia.rpc.blxrbdn.com'
                ],
                nativeToken: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
                geckoId: 'ethereum',
                color: '#627EEA'
            },
            'Base': {
                name: 'Base',
                explorer: 'https://basescan.org',
                rpcs: [
                    'https://mainnet.base.org',
                    'https://base.publicnode.com',
                    'https://base.meowrpc.com',
                    'https://base-mainnet.public.blastapi.io',
                    'https://rpc.ankr.com/base',
                    'https://base.drpc.org',
                    'https://1rpc.io/base',
                    'https://base.blockpi.network/v1/rpc/public'
                ],
                nativeToken: { name: 'Ethereum', symbol: 'ETH', decimals: 18 },
                geckoId: 'ethereum',
                color: '#0052FF'
            },
            'BSC': {
                name: 'BSC',
                explorer: 'https://bscscan.com',
                rpcs: [
                    'https://bsc.publicnode.com',
                    'https://bsc.drpc.org',
                    'https://bsc.meowrpc.com',
                    'https://rpc.ankr.com/bsc',
                    'https://bsc.blockpi.network/v1/rpc/public',
                    'https://bscrpc.com',
                    'https://1rpc.io/bnb',
                    'https://bsc-mainnet.public.blastapi.io',
                    'https://bsc-dataseed1.defibit.io/',
                    'https://binance.nodereal.io',
                    'https://bsc-dataseed.binance.org/'
                ],
                nativeToken: { name: 'BNB', symbol: 'BNB', decimals: 18 },
                geckoId: 'binancecoin',
                color: '#F3BA2F'
            },
            'Polygon': {
                name: 'Polygon',
                explorer: 'https://polygonscan.com',
                rpcs: [
                    'https://polygon-rpc.com',
                    'https://polygon.publicnode.com',
                    'https://polygon-mainnet.public.blastapi.io',
                    'https://rpc.ankr.com/polygon',
                    'https://polygon.meowrpc.com',
                    'https://polygon.drpc.org',
                    'https://rpc-mainnet.matic.network',
                    'https://polygon-bor.publicnode.com',
                    'https://1rpc.io/matic',
                    'https://polygonapi.terminet.io/rpc'
                ],
                nativeToken: { name: 'Polygon', symbol: 'MATIC', decimals: 18 },
                geckoId: 'matic-network',
                color: '#8247E5'
            },
            'Arbitrum': {
                name: 'Arbitrum',
                explorer: 'https://arbiscan.io',
                rpcs: [
                    'https://arb1.arbitrum.io/rpc',
                    'https://arbitrum.publicnode.com',
                    'https://arbitrum-one.public.blastapi.io',
                    'https://rpc.ankr.com/arbitrum',
                    'https://arbitrum.meowrpc.com',
                    'https://arbitrum.drpc.org',
                    'https://1rpc.io/arb',
                    'https://arb-mainnet-public.unifra.io'
                ],
                nativeToken: { name: 'Arbitrum', symbol: 'ARB', decimals: 18 },
                geckoId: 'arbitrum',
                color: '#28A0F0'
            },
            'Optimism': {
                name: 'Optimism',
                explorer: 'https://optimistic.etherscan.io',
                rpcs: [
                    'https://mainnet.optimism.io',
                    'https://optimism.publicnode.com',
                    'https://op-pokt.nodies.app',
                    'https://optimism-mainnet.public.blastapi.io',
                    'https://optimism.meowrpc.com',
                    'https://rpc.ankr.com/optimism',
                    'https://optimism.drpc.org',
                    'https://1rpc.io/op'
                ],
                nativeToken: { name: 'Optimism', symbol: 'OP', decimals: 18 },
                geckoId: 'optimism',
                color: '#FF0420'
            },
            'Avalanche': {
                name: 'Avalanche',
                explorer: 'https://snowtrace.io',
                rpcs: [
                    'https://api.avax.network/ext/bc/C/rpc',
                    'https://avalanche.publicnode.com',
                    'https://avax.meowrpc.com',
                    'https://rpc.ankr.com/avalanche',
                    'https://avalanche-mainnet.public.blastapi.io',
                    'https://avalanche.drpc.org',
                    'https://1rpc.io/avax/c',
                    'https://ava-mainnet.public.blastapi.io'
                ],
                nativeToken: { name: 'Avalanche', symbol: 'AVAX', decimals: 18 },
                geckoId: 'avalanche-2',
                color: '#E84142'
            },
            'SOL': {
                name: 'Solana',
                explorer: 'https://solscan.io',
                rpcs: [
                    'https://api.mainnet-beta.solana.com',
                    'https://rpc.ankr.com/solana',
                    'https://solana.publicnode.com',
                    'https://solana-rpc.publicnode.com',
                    'https://solana.drpc.org',
                    'https://mainnet.helius-rpc.com/?api-key=1d8740dc-e5f4-421c-b823-e1bad1889eff',
                    'https://go.getblock.io/solana-mainnet',
                    'https://solana-mainnet.rpc.extrnode.com'
                ],
                nativeToken: { name: 'Solana', symbol: 'SOL', decimals: 9 },
                geckoId: 'solana',
                color: '#9945FF',
                isEVM: false
            }
        };

        console.log('üöÄ ÏµúÏ†ÅÌôîÎêú RPC ÏÑ§Ï†ï Î°úÎìú ÏôÑÎ£å!');
        console.log('Ï¥ù RPC ÏÑúÎ≤Ñ Ïàò:', Object.values(CHAIN_CONFIG).reduce((sum, chain) => sum + chain.rpcs.length, 0));

        const defaultWallets = {
            "EVM": {},
            "SOL": {}
        };

        // Multicall3 - Î™®Îì† EVM Ï≤¥Ïù∏ÏóêÏÑú ÎèôÏùºÌïú Ï£ºÏÜå
        const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';
        const MULTICALL3_ABI = [
            {
                "inputs": [{"components": [{"name": "target", "type": "address"}, {"name": "callData", "type": "bytes"}], "name": "calls", "type": "tuple[]"}],
                "name": "aggregate",
                "outputs": [{"name": "blockNumber", "type": "uint256"}, {"name": "returnData", "type": "bytes[]"}],
                "type": "function"
            },
            {
                "inputs": [{"components": [{"name": "target", "type": "address"}, {"name": "allowFailure", "type": "bool"}, {"name": "callData", "type": "bytes"}], "name": "calls", "type": "tuple[]"}],
                "name": "aggregate3",
                "outputs": [{"components": [{"name": "success", "type": "bool"}, {"name": "returnData", "type": "bytes"}], "name": "returnData", "type": "tuple[]"}],
                "type": "function"
            }
        ];

        const ERC20_ABI = [
            {
                "constant": true,
                "inputs": [],
                "name": "name",
                "outputs": [{"name": "", "type": "string"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "symbol",
                "outputs": [{"name": "", "type": "string"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [],
                "name": "decimals",
                "outputs": [{"name": "", "type": "uint8"}],
                "type": "function"
            },
            {
                "constant": true,
                "inputs": [{"name": "_owner", "type": "address"}],
                "name": "balanceOf",
                "outputs": [{"name": "balance", "type": "uint256"}],
                "type": "function"
            },
            {
                "anonymous": false,
                "inputs": [
                    {"indexed": true, "name": "from", "type": "address"},
                    {"indexed": true, "name": "to", "type": "address"},
                    {"indexed": false, "name": "value", "type": "uint256"}
                ],
                "name": "Transfer",
                "type": "event"
            }
        ];

        function showMessage(type, message) {
            const messageDiv = document.getElementById(type);
            messageDiv.textContent = message;
            messageDiv.style.display = 'block';
            setTimeout(() => messageDiv.style.display = 'none', 5000);
        }

        function hideMessage(type) {
            document.getElementById(type).style.display = 'none';
        }

        function updateRpcStatus(message, isSuccess = false) {
            const rpcStatus = document.getElementById('rpcStatus');
            rpcStatus.style.display = 'block';
            rpcStatus.textContent = message;
            rpcStatus.className = isSuccess ? 'rpc-status success' : 'rpc-status';
        }

        function updateProgressStep(stepId, status, message = '') {
            const step = document.getElementById(stepId);
            const statusIcon = step.querySelector('span:last-child');

            step.className = `progress-step ${status}`;

            switch(status) {
                case 'active':
                    statusIcon.textContent = 'üîÑ';
                    break;
                case 'completed':
                    statusIcon.textContent = '‚úÖ';
                    break;
                case 'error':
                    statusIcon.textContent = '‚ùå';
                    break;
                default:
                    statusIcon.textContent = '‚è≥';
            }

            if (message) {
                step.querySelector('span:first-child').textContent = message;
            }
        }

        function formatNumber(num) {
            if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(2) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(2) + 'K';
            return num.toLocaleString();
        }

        function getRandomColor() {
            const colors = [
                '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
                '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#36A2EB'
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }

        function copyToClipboard(text, element) {
            navigator.clipboard.writeText(text).then(() => {
                const tooltip = element.querySelector('.copy-tooltip');
                if (tooltip) {
                    tooltip.classList.add('show');
                    setTimeout(() => {
                        tooltip.classList.remove('show');
                    }, 1500);
                }
                console.log('Ï£ºÏÜåÍ∞Ä ÌÅ¥Î¶ΩÎ≥¥ÎìúÏóê Î≥µÏÇ¨Îê®:', text);
            }).catch(err => {
                console.error('ÌÅ¥Î¶ΩÎ≥¥Îìú Î≥µÏÇ¨ Ïã§Ìå®:', err);
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);

                const tooltip = element.querySelector('.copy-tooltip');
                if (tooltip) {
                    tooltip.classList.add('show');
                    setTimeout(() => {
                        tooltip.classList.remove('show');
                    }, 1500);
                }
            });
        }

        // ========== Ï∂úÍ∏à Ï∂îÏ†Å Í∏∞Îä• ==========

        // ÏãúÍ∞Ñ Ìè¨Îß∑ Ìï®Ïàò (Ïòà: "2Î∂Ñ Ï†Ñ", "1ÏãúÍ∞Ñ Ï†Ñ")
        function formatTimeAgo(timestamp) {
            const now = Math.floor(Date.now() / 1000);
            const diff = now - timestamp;

            if (diff < 60) return `${diff}Ï¥à Ï†Ñ`;
            if (diff < 3600) return `${Math.floor(diff / 60)}Î∂Ñ Ï†Ñ`;
            if (diff < 86400) return `${Math.floor(diff / 3600)}ÏãúÍ∞Ñ Ï†Ñ`;
            if (diff < 2592000) return `${Math.floor(diff / 86400)}Ïùº Ï†Ñ`;
            return `${Math.floor(diff / 2592000)}Í∞úÏõî Ï†Ñ`;
        }

        // Ï∂úÍ∏à ÎÇ¥Ïó≠ Ï°∞Ìöå (getPastEvents ÏÇ¨Ïö©)
        // ERC20 Transfer topic0 (keccak256 hash - Ìï≠ÏÉÅ ÎèôÏùº)
        const TRANSFER_TOPIC0 = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';

        // address -> topic (32 bytes, lowercased)
        function addressToTopic(addr) {
            const a = addr.toLowerCase().replace(/^0x/, '');
            return '0x' + a.padStart(64, '0');
        }

        // ÏµúÏã† ERC20 Ï∂úÍ∏à 1Í±¥Îßå Ï∞æÍ∏∞ (logs Í∏∞Î∞ò, Î∏îÎ°ù Î≤îÏúÑ Ï†êÏßÑ ÌôïÏû•)
        async function getLatestWithdrawal(walletAddress, tokenAddress, decimals) {
            try {
                if (!web3 || currentChain === 'SOL') return null;
                if (!tokenAddress || tokenAddress === '0x0000000000000000000000000000000000000000') return null; // ÎÑ§Ïù¥Ìã∞Î∏åÎäî Ï†úÏô∏

                const from = web3.utils.toChecksumAddress(walletAddress);
                const fromTopic = addressToTopic(from);

                const latestBlock = await Promise.race([
                    web3.eth.getBlockNumber(),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('getBlockNumber timeout')), 1500))
                ]);

                // Î∏îÎ°ù Î≤îÏúÑ Ï†êÏßÑ ÌôïÏû•: 1k -> 3k -> 5k (Rate Limit ÎåÄÏùë)
                const ranges = [1000, 3000, 5000];

                for (const r of ranges) {
                    const fromBlock = Math.max(0, latestBlock - r);

                    try {
                        const logs = await Promise.race([
                            web3.eth.getPastLogs({
                                fromBlock,
                                toBlock: 'latest',
                                address: tokenAddress,
                                topics: [TRANSFER_TOPIC0, fromTopic] // Transfer(from=wallet, to=any)
                            }),
                            new Promise((_, reject) => setTimeout(() => reject(new Error('getPastLogs timeout')), 5000))
                        ]);

                        if (!logs || logs.length === 0) continue;

                        // ÏµúÏã† Î°úÍ∑∏ ÏÑ†ÌÉù: blockNumber -> logIndex Í∏∞Ï§Ä
                        logs.sort((a, b) => (b.blockNumber - a.blockNumber) || (b.logIndex - a.logIndex));
                        const latest = logs[0];

                        // topics[2] = to (indexed), data = value
                        const toTopic = latest.topics[2]; // 32 bytes
                        const to = '0x' + toTopic.slice(26); // last 20 bytes
                        const valueRaw = web3.utils.toBN(latest.data);
                        const amount = parseFloat(valueRaw.toString()) / Math.pow(10, decimals);

                        // timestampÎäî ÏµúÏã† 1Í±¥Îßå Î∏îÎ°ù Ï°∞Ìöå (Ï∫êÏãú ÏÇ¨Ïö©)
                        const tsKey = `${currentChain}-${latest.blockNumber}`;
                        let timestamp = blockTimestampCache[tsKey];
                        if (!timestamp) {
                            try {
                                const block = await Promise.race([
                                    web3.eth.getBlock(latest.blockNumber),
                                    new Promise((_, reject) => setTimeout(() => reject(new Error('getBlock timeout')), 1500))
                                ]);
                                timestamp = block?.timestamp ? Number(block.timestamp) : 0;
                                blockTimestampCache[tsKey] = timestamp || 0;
                            } catch (e) {
                                timestamp = 0;
                            }
                        }

                        return {
                            txHash: latest.transactionHash,
                            blockNumber: latest.blockNumber,
                            to,
                            amount,
                            timestamp
                        };
                    } catch (rangeError) {
                        // Rate limit ÎòêÎäî ÌÉÄÏûÑÏïÑÏõÉ - Îã§Ïùå Î≤îÏúÑ ÏãúÎèÑ
                        const errorMsg = rangeError.message || rangeError.toString();
                        if (errorMsg.includes('limit exceeded') || errorMsg.includes('rate limit')) {
                            console.log(`‚ö†Ô∏è [Rate Limit] ${r} Î∏îÎ°ù Î≤îÏúÑ Ïã§Ìå®, Ï∂ïÏÜå ÏãúÎèÑ...`);
                            continue;
                        }
                        // Í∏∞ÌÉÄ ÏóêÎü¨Îäî Îã§Ïùå Î≤îÏúÑ ÏãúÎèÑ
                        continue;
                    }
                }

                return null;
            } catch (error) {
                console.error('ÏµúÏã† Ï∂úÍ∏à Ï°∞Ìöå Ïã§Ìå®:', walletAddress, error);
                return null;
            }
        }

        // Ï∂úÍ∏à ÏÖÄ ÏóÖÎç∞Ïù¥Ìä∏
        function updateWithdrawalCell(cellId, withdrawals, walletAddress) {
            const cell = document.getElementById(cellId);
            if (!cell) return;

            if (withdrawals.length === 0) {
                cell.innerHTML = '<span style="color: #666;">-</span>';
                return;
            }

            const latest = withdrawals[0];
            const explorerUrl = CHAIN_CONFIG[currentChain].explorer;
            const txUrl = `${explorerUrl}/tx/${latest.txHash}`;

            let html = `<div class="withdrawal-cell">`;

            // Î©îÏù∏ Í∏àÏï° (ÌÅ¨Í≤å, Î™ÖÌôïÌïòÍ≤å)
            html += `<div class="withdrawal-main">`;
            html += `<span class="withdrawal-amount-big">${formatNumber(latest.amount)}</span>`;

            // ÌûàÏä§ÌÜ†Î¶¨ Ïπ¥Ïö¥Ìä∏
            if (withdrawals.length > 1) {
                html += `<span class="withdrawal-count" onclick="toggleDropdown('${cellId}')" title="Show history">‚ñº ${withdrawals.length}</span>`;
            }
            html += `</div>`;

            // ÏûëÏùÄ Ìä∏ÎûúÏû≠ÏÖò ÎßÅÌÅ¨
            html += `<a href="${txUrl}" target="_blank" class="withdrawal-tx-link" title="View on explorer">${latest.txHash.substring(0, 10)}...</a>`;

            // ÎìúÎ°≠Îã§Ïö¥ ÌûàÏä§ÌÜ†Î¶¨
            if (withdrawals.length > 1) {
                html += `<div class="withdrawal-dropdown" id="dropdown-${cellId}">`;
                withdrawals.forEach((w, idx) => {
                    const wTxUrl = `${explorerUrl}/tx/${w.txHash}`;
                    const wTime = w.timestamp ? formatTimeAgo(w.timestamp) : '';
                    html += `<div class="withdrawal-item">`;
                    html += `<div class="withdrawal-item-header">`;
                    html += `<span class="withdrawal-item-amount">${formatNumber(w.amount)}</span>`;
                    if (wTime) html += `<span class="withdrawal-item-time">${wTime}</span>`;
                    html += `</div>`;
                    html += `<div class="withdrawal-item-details">`;
                    html += `<span class="withdrawal-item-to">‚Üí ${w.to.substring(0, 12)}...</span>`;
                    html += `<a href="${wTxUrl}" target="_blank" class="withdrawal-item-link">View</a>`;
                    html += `</div>`;
                    html += `</div>`;
                });
                html += `</div>`;
            }

            html += `</div>`;
            cell.innerHTML = html;
        }

        // ÏãúÍ∞Ñ ÏÖÄ ÏóÖÎç∞Ïù¥Ìä∏
        function updateTimeCell(cellId, withdrawals) {
            const cell = document.getElementById(cellId);
            if (!cell || withdrawals.length === 0) {
                if (cell) cell.innerHTML = '<span style="color: #666;">-</span>';
                return;
            }

            const latest = withdrawals[0];
            if (latest.timestamp) {
                const timeAgo = formatTimeAgo(latest.timestamp);
                const isRecent = (Math.floor(Date.now() / 1000) - latest.timestamp) < 3600; // 1ÏãúÍ∞Ñ Ïù¥ÎÇ¥
                cell.innerHTML = `<span class="time-badge ${isRecent ? 'recent' : ''}">${timeAgo}</span>`;
            } else {
                cell.innerHTML = '<span style="color: #666;">-</span>';
            }
        }

        // ÎìúÎ°≠Îã§Ïö¥ ÌÜ†Í∏Ä
        function toggleDropdown(cellId) {
            const dropdown = document.getElementById(`dropdown-${cellId}`);
            if (!dropdown) return;

            // Îã§Î•∏ ÎìúÎ°≠Îã§Ïö¥ Î™®Îëê Îã´Í∏∞
            document.querySelectorAll('.withdrawal-dropdown').forEach(d => {
                if (d.id !== `dropdown-${cellId}`) {
                    d.classList.remove('show');
                }
            });

            dropdown.classList.toggle('show');

            // Ïô∏Î∂Ä ÌÅ¥Î¶≠Ïãú Îã´Í∏∞
            if (dropdown.classList.contains('show')) {
                setTimeout(() => {
                    document.addEventListener('click', function closeDropdown(e) {
                        if (!dropdown.contains(e.target) && e.target.className !== 'withdrawal-toggle') {
                            dropdown.classList.remove('show');
                            document.removeEventListener('click', closeDropdown);
                        }
                    });
                }, 10);
            }
        }

        // Ï£ºÏÜåÎ°ú Í±∞ÎûòÏÜå Ïù¥Î¶Ñ Ï∞æÍ∏∞
        function findExchangeNameByAddress(address) {
            const walletSource = wallets.EVM || {};
            for (const [name, walletData] of Object.entries(walletSource)) {
                const walletAddr = (typeof walletData === 'object' && walletData.address) ? walletData.address : walletData;
                if (walletAddr && walletAddr.toLowerCase() === address.toLowerCase()) {
                    return name;
                }
            }
            return null;
        }

        // ÌäπÏ†ï Í±∞ÎûòÏÜåÏùò Ï∂úÍ∏à UI ÏóÖÎç∞Ïù¥Ìä∏
        async function updateWithdrawalForExchange(name, newWithdrawal) {
            const safeName = name.replace(/[^a-zA-Z0-9]/g, '_');
            const withdrawalCellId = `withdrawal-${safeName}`;
            const timeCellId = `time-${safeName}`;

            const address = (typeof wallets.EVM[name] === 'object') ? wallets.EVM[name].address : wallets.EVM[name];
            const cacheKey = `${currentChain}-${address}-${currentTokenAddress}`;

            // ÌûàÏä§ÌÜ†Î¶¨ ÏóÖÎç∞Ïù¥Ìä∏
            const prevHistory = withdrawalCache[cacheKey] || [];
            let nextHistory = [newWithdrawal];

            for (const w of prevHistory) {
                if (!w || !w.txHash) continue;
                if (w.txHash === newWithdrawal.txHash) continue;
                nextHistory.push(w);
                if (nextHistory.length >= WITHDRAWAL_HISTORY_LIMIT) break;
            }

            withdrawalCache[cacheKey] = nextHistory;
            lastSeenWithdrawalTx[cacheKey] = newWithdrawal.txHash;

            updateWithdrawalCell(withdrawalCellId, nextHistory, address);
            updateTimeCell(timeCellId, nextHistory);

            console.log(`üÜï [Ïã§ÏãúÍ∞Ñ] ${name} ÏÉà Ï∂úÍ∏à: ${newWithdrawal.amount.toFixed(2)} (${newWithdrawal.txHash.substring(0, 10)}...)`);
        }

        // ÏÉà Ï∂úÍ∏à Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨
        async function handleNewWithdrawalEvent(log) {
            try {
                // Parse Transfer event
                const fromTopic = log.topics[1];
                const toTopic = log.topics[2];
                const from = '0x' + fromTopic.slice(26);
                const to = '0x' + toTopic.slice(26);
                const valueRaw = web3.utils.toBN(log.data);
                const amount = parseFloat(valueRaw.toString()) / Math.pow(10, currentTokenDecimals);

                // Find exchange name
                const name = findExchangeNameByAddress(from);
                if (!name) return;

                console.log(`üì° [WebSocket] Transfer Í∞êÏßÄ: ${name} ‚Üí ${amount.toFixed(2)}`);

                // Get timestamp (cached)
                const tsKey = `${currentChain}-${log.blockNumber}`;
                let timestamp = blockTimestampCache[tsKey];
                if (!timestamp) {
                    try {
                        const block = await web3.eth.getBlock(log.blockNumber);
                        timestamp = block ? Number(block.timestamp) : 0;
                        blockTimestampCache[tsKey] = timestamp || 0;
                    } catch (e) {
                        timestamp = 0;
                    }
                }

                const withdrawal = {
                    txHash: log.transactionHash,
                    blockNumber: log.blockNumber,
                    to,
                    amount,
                    timestamp
                };

                await updateWithdrawalForExchange(name, withdrawal);
            } catch (error) {
                console.error('Ï∂úÍ∏à Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨ Ïã§Ìå®:', error);
            }
        }

        // WebSocket logs Íµ¨ÎèÖ (Ïã§ÏãúÍ∞Ñ Ï∂úÍ∏à Í∞êÏßÄ)
        function subscribeToWithdrawals(top10Addresses) {
            try {
                if (currentChain === 'SOL') {
                    console.log('SOL Ï≤¥Ïù∏ÏùÄ WebSocket Ï∂úÍ∏à Î™®ÎãàÌÑ∞ÎßÅ ÎØ∏ÏßÄÏõê');
                    return;
                }

                if (!currentRpcUrl || !currentTokenAddress) return;

                const wsUrl = currentRpcUrl.replace('https://', 'wss://').replace('http://', 'ws://');
                console.log(`üîå [WebSocket] Ïó∞Í≤∞ ÏãúÎèÑ: ${wsUrl}`);
                console.log(`üìç [WebSocket] ÌòÑÏû¨ RPC: ${currentRpcUrl}`);
                console.log(`üéØ [WebSocket] Top ${top10Addresses.length}Í∞ú ÏßÄÍ∞ë Î™®ÎãàÌÑ∞ÎßÅ Ï§ÄÎπÑ`);

                wsConnection = new WebSocket(wsUrl);

                // Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ (10Ï¥à)
                const connectionTimeout = setTimeout(() => {
                    if (wsConnection && wsConnection.readyState !== WebSocket.OPEN) {
                        console.error('‚è±Ô∏è [WebSocket] Ïó∞Í≤∞ ÌÉÄÏûÑÏïÑÏõÉ (10Ï¥à) - RPCÍ∞Ä WebSocketÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Í≤É Í∞ôÏäµÎãàÎã§');
                        wsConnection.close();
                    }
                }, 10000);

                wsConnection.onopen = () => {
                    clearTimeout(connectionTimeout);
                    console.log('‚úÖ [WebSocket] Ïó∞Í≤∞ ÏÑ±Í≥µ!');
                    console.log(`‚ö° [WebSocket] Ïã§ÏãúÍ∞Ñ Î™®Îìú ÌôúÏÑ±Ìôî - RPCÍ∞Ä WebSocketÏùÑ ÏßÄÏõêÌï©ÎãàÎã§!`);
                    reconnectAttempts = 0;
                    isWebSocketActive = true;

                    // Polling Ï§ëÏßÄ (WebSocketÏù¥ ÏûëÎèôÌïòÎØÄÎ°ú)
                    stopPolling();

                    // Subscribe to Transfer events from Top 10 wallets
                    const fromTopics = top10Addresses.map(addr => addressToTopic(addr));

                    const subscribeMessage = {
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'eth_subscribe',
                        params: [
                            'logs',
                            {
                                address: currentTokenAddress,
                                topics: [TRANSFER_TOPIC0, fromTopics]
                            }
                        ]
                    };

                    console.log(`üì° [WebSocket] Transfer Ïù¥Î≤§Ìä∏ Íµ¨ÎèÖ Ï§ë... (Top ${top10Addresses.length}Í∞ú ÏßÄÍ∞ë)`);
                    wsConnection.send(JSON.stringify(subscribeMessage));
                };

                wsConnection.onmessage = async (event) => {
                    try {
                        const data = JSON.parse(event.data);

                        // Subscription confirmation
                        if (data.result && !data.params) {
                            console.log(`‚úÖ [WebSocket] Íµ¨ÎèÖ ÏôÑÎ£å! ID: ${data.result}`);
                            return;
                        }

                        // New log event
                        if (data.params && data.params.result) {
                            await handleNewWithdrawalEvent(data.params.result);
                        }
                    } catch (error) {
                        console.error('WebSocket Î©îÏãúÏßÄ Ï≤òÎ¶¨ Ïã§Ìå®:', error);
                    }
                };

                wsConnection.onerror = (error) => {
                    clearTimeout(connectionTimeout);
                    console.error('‚ùå [WebSocket] Ïò§Î•ò Î∞úÏÉù');
                    console.error('‚ùå [WebSocket] ÏóêÎü¨ ÌÉÄÏûÖ:', error.type || 'unknown');
                    console.error('‚ùå [WebSocket] ÏõêÏù∏: RPCÍ∞Ä WebSocket(wss://)ÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÍ±∞ÎÇò Î∞©ÌôîÎ≤Ω Ï∞®Îã®');
                    console.log('üîÑ [Hybrid] Polling Î™®ÎìúÎ°ú Fallback...');

                    // Fallback to Polling
                    isWebSocketActive = false;
                    startPolling();
                };

                wsConnection.onclose = (event) => {
                    clearTimeout(connectionTimeout);
                    console.log('üîå [WebSocket] Ïó∞Í≤∞ Ï¢ÖÎ£å');
                    console.log(`üîå [WebSocket] Ï¢ÖÎ£å ÏΩîÎìú: ${event.code}, Ïù¥Ïú†: ${event.reason || 'ÏóÜÏùå'}`);
                    console.log(`üîå [WebSocket] Ï†ïÏÉÅ Ï¢ÖÎ£å: ${event.wasClean ? 'Ïòà' : 'ÏïÑÎãàÏò§'}`);
                    wsConnection = null;
                    isWebSocketActive = false;

                    // Fallback to Polling (Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ Ï†úÍ±∞)
                    if (!isPollingActive) {
                        console.log('üîÑ [Hybrid] Polling Î™®ÎìúÎ°ú Fallback...');
                        startPolling();
                    }
                };

            } catch (error) {
                console.error('WebSocket Íµ¨ÎèÖ Ïã§Ìå®:', error);
            }
        }

        // WebSocket Ï†ïÎ¶¨
        function cleanupWebSocket() {
            if (wsConnection) {
                wsConnection.close();
                wsConnection = null;
            }
            reconnectAttempts = 0;
            isWebSocketActive = false;
        }

        // Polling ÏãúÏûë (Hybrid Î™®Îìú Fallback)
        function startPolling() {
            if (isPollingActive) return; // Ïù¥ÎØ∏ Ïã§Ìñâ Ï§ëÏù¥Î©¥ Î¨¥Ïãú

            console.log(`üîÑ [Polling] Polling Î™®Îìú ÏãúÏûë (${WITHDRAWAL_POLL_INTERVAL_MS / 1000}Ï¥à Ï£ºÍ∏∞)`);
            isPollingActive = true;

            // Ï¶âÏãú 1Ìöå Ïã§Ìñâ
            pollTop10Withdrawals(currentTop10Names);

            // ÌÉÄÏù¥Î®∏ ÏãúÏûë
            withdrawalPollTimer = setInterval(() => {
                if (!isWebSocketActive && isPollingActive) {
                    pollTop10Withdrawals(currentTop10Names);
                }
            }, WITHDRAWAL_POLL_INTERVAL_MS);
        }

        // Polling Ï§ëÏßÄ
        function stopPolling() {
            if (withdrawalPollTimer) {
                clearInterval(withdrawalPollTimer);
                withdrawalPollTimer = null;
            }
            isPollingActive = false;
            console.log('‚è∏Ô∏è [Polling] Polling Î™®Îìú Ï§ëÏßÄ');
        }

        // ÏÉà Ï∂úÍ∏à Ï≤òÎ¶¨
        function handleNewWithdrawal(data) {
            console.log('üÜï ÏÉà Ï∂úÍ∏à Í∞êÏßÄ:', data);
        }

        function stopWithdrawalMonitoring() {
            stopPolling();
            cleanupWebSocket();
            currentTop10Addresses = [];
            currentTop10Names = [];
        }

        async function pollTop10Withdrawals(top10Names) {
            if (currentChain === 'SOL') {
                console.log(`‚ùå [Ìè¥ÎßÅ] SOL Ï≤¥Ïù∏ÏùÄ ÎØ∏ÏßÄÏõê`);
                return;
            }
            if (!web3) {
                console.log(`‚ùå [Ìè¥ÎßÅ] web3 Í∞ùÏ≤¥ ÏóÜÏùå`);
                return;
            }
            if (!currentTokenAddress || currentTokenAddress === '0x0000000000000000000000000000000000000000') {
                console.log(`‚ùå [Ìè¥ÎßÅ] ÎÑ§Ïù¥Ìã∞Î∏å ÌÜ†ÌÅ∞ÏùÄ ÎØ∏ÏßÄÏõê`);
                return;
            }

            console.log(`üìã [Ìè¥ÎßÅ] ${top10Names.length}Í∞ú ÏßÄÍ∞ë Ï°∞Ìöå ÏãúÏûë`);

            for (const name of top10Names) {
                const walletSource = wallets.EVM || {};
                const walletData = walletSource[name];
                if (!walletData) continue;

                const address = (typeof walletData === 'object' && walletData.address) ? walletData.address : walletData;
                if (!address || typeof address !== 'string') continue;

                const safeName = name.replace(/[^a-zA-Z0-9]/g, '_');
                const withdrawalCellId = `withdrawal-${safeName}`;
                const timeCellId = `time-${safeName}`;

                const cacheKey = `${currentChain}-${address}-${currentTokenAddress}`;

                // ÏµúÏã† 1Í±¥ Ï°∞Ìöå
                console.log(`  üîé [${name}] ÏµúÏã† Ï∂úÍ∏à Ï°∞Ìöå Ï§ë...`);
                const latest = await getLatestWithdrawal(address, currentTokenAddress, currentTokenDecimals);

                if (!latest) {
                    console.log(`  ‚ûñ [${name}] ÏµúÍ∑º Ï∂úÍ∏à ÏóÜÏùå`);
                    continue;
                }

                console.log(`  ‚úÖ [${name}] Ï∂úÍ∏à Î∞úÍ≤¨: ${latest.amount.toFixed(2)} (${latest.txHash.substring(0, 10)}...)`);

                // ÏÉà Ï∂úÍ∏à Í∞êÏßÄ(Ìä∏ÎûúÏû≠ÏÖò Ìï¥Ïãú Í∏∞Ï§Ä)
                const prevTx = lastSeenWithdrawalTx[cacheKey];
                const isNew = prevTx && prevTx !== latest.txHash;

                // ÌûàÏä§ÌÜ†Î¶¨ Ï∫êÏãú Íµ¨ÏÑ±: [latest, ...old] (Ï§ëÎ≥µ Ï†úÍ±∞, ÏµúÎåÄ 10Í∞ú)
                const prevHistory = withdrawalCache[cacheKey] || [];
                let nextHistory = [];

                // Ìï≠ÏÉÅ ÏµúÏã†ÏùÑ Îß® ÏïûÏóê
                nextHistory.push(latest);

                // Í∏∞Ï°¥ latestÍ∞Ä Î∞îÎÄê Í≤ΩÏö∞, Í∏∞Ï°¥ Í∏∞Î°ùÏùÑ Îí§Î°ú Î∞ÄÍ∏∞
                for (const w of prevHistory) {
                    if (!w || !w.txHash) continue;
                    if (w.txHash === latest.txHash) continue; // Ï§ëÎ≥µ Ï†úÍ±∞
                    nextHistory.push(w);
                    if (nextHistory.length >= WITHDRAWAL_HISTORY_LIMIT) break;
                }

                withdrawalCache[cacheKey] = nextHistory;
                lastSeenWithdrawalTx[cacheKey] = latest.txHash;

                // UI ÏóÖÎç∞Ïù¥Ìä∏ (ÏµúÏã† + ÎìúÎ°≠Îã§Ïö¥ ÌûàÏä§ÌÜ†Î¶¨)
                updateWithdrawalCell(withdrawalCellId, nextHistory, address);
                updateTimeCell(timeCellId, nextHistory);

                // ÏÉà Ï∂úÍ∏àÏù¥Î©¥ (ÏÑ†ÌÉù) ÏΩòÏÜî ÌëúÏãú Ï†ïÎèÑÎßå.
                if (isNew) {
                    console.log(`üÜï NEW withdrawal detected: ${name} ${latest.txHash}`);
                }

                // Í≥ºÎ∂ÄÌïò Î∞©ÏßÄ: ÏßÄÍ∞ë Í∞Ñ ÏßßÏùÄ ÎîúÎ†àÏù¥
                await new Promise(resolve => setTimeout(resolve, 120));
            }
        }

        async function startWithdrawalMonitoring(sortedBalancesArray) {
            // sortedBalancesArray: [[name, balance], ...] (Ïù¥ÎØ∏ ÌÅ∞ Ïàú Ï†ïÎ†¨Îêú Î∞∞Ïó¥)
            if (currentChain === 'SOL') return;
            if (!sortedBalancesArray || sortedBalancesArray.length === 0) return;
            if (!currentTokenAddress || currentTokenAddress === '0x0000000000000000000000000000000000000000') return; // ÎÑ§Ïù¥Ìã∞Î∏å Ï†úÏô∏

            stopWithdrawalMonitoring();

            // Top 10 names
            const top10 = sortedBalancesArray.slice(0, 10).map(([name]) => name);

            console.log(`üîç [ÏãúÏûë] Top 10 Ï∂úÍ∏à Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë`);
            console.log(`  Í±∞ÎûòÏÜå: ${top10.join(', ')}`);

            // Ï¶âÏãú 1Ìöå Ïã§Ìñâ (Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Î°úÎìú)
            console.log(`üöÄ [Ï¥àÍ∏∞] Ï≤´ Ï°∞Ìöå ÏãúÏûë...`);
            await pollTop10Withdrawals(top10);
            console.log(`‚úÖ [Ï¥àÍ∏∞] Ï≤´ Ï°∞Ìöå ÏôÑÎ£å`);

            // WebSocket Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ ÏãúÏûë
            const top10Addresses = sortedBalancesArray.slice(0, 10).map(([name]) => {
                const walletData = (wallets.EVM || {})[name];
                return (typeof walletData === 'object' && walletData.address) ? walletData.address : walletData;
            }).filter(addr => addr);

            // Ï†ÑÏó≠ Î≥ÄÏàòÏóê Ï†ÄÏû• (Hybrid Î™®ÎìúÏóêÏÑú ÏÇ¨Ïö©)
            currentTop10Addresses = top10Addresses;
            currentTop10Names = top10;

            if (top10Addresses.length > 0 && currentRpcUrl) {
                console.log(`üéØ [Hybrid] WebSocket ÏãúÎèÑ Ï§ë... (Ïã§Ìå® Ïãú ÏûêÎèôÏúºÎ°ú Polling Ï†ÑÌôò)`);
                console.log(`  Ï£ºÏÜå: ${top10Addresses.map(a => a.substring(0, 8) + '...').join(', ')}`);
                subscribeToWithdrawals(top10Addresses);
                // WebSocket Ïã§Ìå® Ïãú onerror/oncloseÏóêÏÑú ÏûêÎèôÏúºÎ°ú startPolling() Ìò∏Ï∂ú
            } else {
                // WebSocket ÏãúÎèÑ Ï°∞Í±¥ Ïïà ÎßûÏúºÎ©¥ Î∞îÎ°ú Polling
                console.log(`‚ö†Ô∏è [Hybrid] WebSocket Î∂àÍ∞Ä - Polling Î™®Îìú ÏãúÏûë`);
                startPolling();
            }
        }

        // Page Visibility API - Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú ÏÑ±Îä• ÏµúÏ†ÅÌôî
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                console.log('üì¥ ÌéòÏù¥ÏßÄÍ∞Ä Î∞±Í∑∏ÎùºÏö¥ÎìúÎ°ú Ïù¥Îèô - WebSocket ÏùºÏãú Ï§ëÏßÄ');
                cleanupWebSocket();
            } else {
                console.log('üì± ÌéòÏù¥ÏßÄÍ∞Ä Ìè¨Í∑∏ÎùºÏö¥ÎìúÎ°ú Î≥µÍ∑Ä');

                // WebSocket Ïû¨ÏãúÎèÑ
                if (currentRpcUrl && currentChain !== 'SOL' && currentTop10Addresses.length > 0) {
                    console.log('üîÑ [Ïû¨Ïó∞Í≤∞] Top 10 WebSocket Íµ¨ÎèÖ Ïû¨ÏãúÏûë...');
                    subscribeToWithdrawals(currentTop10Addresses);
                }

                // Polling Ï¶âÏãú 1Ìöå Ïã§Ìñâ (ÏµúÏã† Îç∞Ïù¥ÌÑ∞ Î≥¥Ïû•)
                if (isPollingActive && currentTop10Names.length > 0) {
                    console.log('üîÑ [Ìè¨Í∑∏ÎùºÏö¥Îìú Î≥µÍ∑Ä] Ï¶âÏãú ÏóÖÎç∞Ïù¥Ìä∏ Ïã§Ìñâ...');
                    pollTop10Withdrawals(currentTop10Names);
                }
            }
        });

        // ========== Ï∂úÍ∏à Ï∂îÏ†Å Í∏∞Îä• ÎÅù ==========

        async function initializeFirebase() {
            try {
                console.log('Firebase Ï¥àÍ∏∞Ìôî ÏãúÎèÑ Ï§ë...');

                const app = firebase.initializeApp(firebaseConfig);
                database = firebase.database();

                await database.ref('.info/connected').once('value');

                console.log('Firebase Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
                showMessage('success', 'Firebase ÌÅ¥ÎùºÏö∞Îìú Ïó∞Í≤∞ ÏÑ±Í≥µ!');
                return true;
            } catch (error) {
                console.error('Firebase Ï¥àÍ∏∞Ìôî Ïã§Ìå®:', error);
                showMessage('warning', 'Firebase Ïó∞Í≤∞ Ïã§Ìå®. Î°úÏª¨ Î™®ÎìúÎ°ú Ïã§ÌñâÎê©ÎãàÎã§.');
                return false;
            }
        }

        async function loadWallets() {
            try {
                if (database) {
                    const snapshot = await database.ref('wallets').once('value');
                    const firebaseWallets = snapshot.val();

                    if (firebaseWallets) {
                        wallets = firebaseWallets;
                        console.log('FirebaseÏóêÏÑú ÏßÄÍ∞ë Îç∞Ïù¥ÌÑ∞ Î°úÎìúÎê®');
                        checkForArrayAddresses();
                    } else {
                        wallets = JSON.parse(JSON.stringify(defaultWallets));
                        console.log('FirebaseÏóê ÏßÄÍ∞ë Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏùå. Îπà ÏÉÅÌÉúÎ°ú ÏãúÏûë');
                    }
                } else {
                    wallets = JSON.parse(JSON.stringify(defaultWallets));
                    console.log('Firebase ÎØ∏Ïó∞Í≤∞: Îπà ÏßÄÍ∞ëÏúºÎ°ú ÏãúÏûë');
                }

                ensureChainWallets();
                displayWallets();
            } catch (error) {
                console.error('ÏßÄÍ∞ë Î°úÎìú Ïã§Ìå®:', error);
                wallets = JSON.parse(JSON.stringify(defaultWallets));
                ensureChainWallets();
                displayWallets();
            }
        }

        function checkForArrayAddresses() {
            let hasArrayAddress = false;
            let hasOldFormat = false;

            if (wallets.EVM) {
                for (const [name, walletData] of Object.entries(wallets.EVM)) {
                    if (Array.isArray(walletData)) {
                        hasArrayAddress = true;
                        console.warn(`‚ö†Ô∏è Î∞∞Ïó¥ Ï£ºÏÜå Î∞úÍ≤¨: ${name} = ${walletData}`);
                    } else if (typeof walletData === 'string') {
                        hasOldFormat = true;
                        console.warn(`‚ö†Ô∏è Íµ¨ÌòïÏãù Ï£ºÏÜå Î∞úÍ≤¨: ${name} = ${walletData}`);
                    }
                }
            }

            const warningDiv = document.getElementById('arrayWarning');
            if (hasArrayAddress || hasOldFormat) {
                warningDiv.style.display = 'block';
                if (hasOldFormat) {
                    warningDiv.innerHTML = '‚ö†Ô∏è ÏùºÎ∂Ä ÏßÄÍ∞ëÏù¥ Íµ¨ÌòïÏãùÏúºÎ°ú Ï†ÄÏû•ÎêòÏñ¥ ÏûàÏäµÎãàÎã§. <button class="fix-button" onclick="fixArrayAddresses()">ÏûêÎèô ÏàòÏ†ï</button>';
                }
            } else {
                warningDiv.style.display = 'none';
            }
        }

        async function fixArrayAddresses() {
            if (!database) {
                showMessage('error', 'FirebaseÏóê Ïó∞Í≤∞ÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.');
                return;
            }

            try {
                console.log('üîß ÏßÄÍ∞ë ÌòïÏãù ÏûêÎèô ÏàòÏ†ï ÏãúÏûë...');

                let fixedCount = 0;
                const evmWallets = wallets.EVM || {};

                for (const [name, walletData] of Object.entries(evmWallets)) {
                    if (Array.isArray(walletData)) {
                        if (walletData.length > 0) {
                            console.log(`üîß Î∞∞Ïó¥‚ÜíÍ∞ùÏ≤¥ ÏàòÏ†ï: ${name} - ${walletData} ‚Üí { address: ${walletData[0]}, region: FOREIGN }`);
                            evmWallets[name] = { address: walletData[0], region: 'FOREIGN' };
                            fixedCount++;
                        } else {
                            console.warn(`‚ö†Ô∏è Îπà Î∞∞Ïó¥ ÏÇ≠Ï†ú: ${name}`);
                            delete evmWallets[name];
                            fixedCount++;
                        }
                    } else if (typeof walletData === 'string') {
                        console.log(`üîß Î¨∏ÏûêÏó¥‚ÜíÍ∞ùÏ≤¥ ÏàòÏ†ï: ${name} - ${walletData} ‚Üí { address: ${walletData}, region: FOREIGN }`);
                        evmWallets[name] = { address: walletData, region: 'FOREIGN' };
                        fixedCount++;
                    }
                }

                if (fixedCount > 0) {
                    wallets.EVM = evmWallets;
                    await database.ref('wallets/EVM').set(evmWallets);

                    showMessage('success', `‚úÖ ${fixedCount}Í∞úÏùò ÏßÄÍ∞ëÏù¥ ÏÉà ÌòïÏãùÏúºÎ°ú Î≥ÄÌôòÎêòÏóàÏäµÎãàÎã§!`);

                    displayWallets();
                    document.getElementById('arrayWarning').style.display = 'none';

                    console.log(`‚úÖ ${fixedCount}Í∞ú ÏßÄÍ∞ë ÌòïÏãù ÏàòÏ†ï ÏôÑÎ£å`);
                } else {
                    showMessage('warning', 'ÏàòÏ†ïÌï† ÏßÄÍ∞ëÏù¥ ÏóÜÏäµÎãàÎã§.');
                }

            } catch (error) {
                console.error('ÏßÄÍ∞ë ÌòïÏãù ÏàòÏ†ï Ïã§Ìå®:', error);
                showMessage('error', 'ÏßÄÍ∞ë ÌòïÏãù ÏàòÏ†ï Ïã§Ìå®: ' + error.message);
            }
        }

        async function saveWallets() {
            try {
                if (database) {
                    console.log('FirebaseÏóê ÏßÄÍ∞ë Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏãúÎèÑ...');
                    await database.ref('wallets').set(wallets);
                    console.log('FirebaseÏóê ÏßÄÍ∞ë Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû• ÏôÑÎ£å');
                    return true;
                } else {
                    console.log('Firebase ÎØ∏Ïó∞Í≤∞: Ï†ÄÏû• Í±¥ÎÑàÎúÄ');
                    return false;
                }
            } catch (error) {
                console.error('Firebase Ï†ÄÏû• Ïã§Ìå®:', error);
                showMessage('error', 'Firebase Ï†ÄÏû• Ïã§Ìå®: ' + error.message);
                return false;
            }
        }

        function ensureChainWallets() {
            if (!wallets.EVM) {
                wallets.EVM = {};
            }
            if (!wallets.SOL) {
                wallets.SOL = {};
            }
        }

        function findWalletByAddressEVM(address) {
            const normalizedAddress = address.toLowerCase().trim();
            if (wallets.EVM) {
                for (const [name, walletData] of Object.entries(wallets.EVM)) {
                    let compareAddress;
                    if (typeof walletData === 'object' && walletData.address) {
                        compareAddress = walletData.address;
                    } else if (Array.isArray(walletData)) {
                        compareAddress = walletData[0];
                    } else {
                        compareAddress = walletData;
                    }
                    if (compareAddress && compareAddress.toLowerCase().trim() === normalizedAddress) {
                        return { name };
                    }
                }
            }
            return null;
        }

        async function connectToChain(chain) {
            try {
                updateProgressStep('step1', 'active', '1. Î∏îÎ°ùÏ≤¥Ïù∏ Ïó∞Í≤∞ Ï§ë...');

                const chainConfig = CHAIN_CONFIG[chain];
                if (!chainConfig) {
                    throw new Error('ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Ï≤¥Ïù∏ÏûÖÎãàÎã§: ' + chain);
                }

                // Ï∫êÏãúÎêú RPCÍ∞Ä ÏûàÏúºÎ©¥ Î®ºÏ†Ä ÏãúÎèÑ
                if (rpcCache[chain]) {
                    const cachedRpc = rpcCache[chain];
                    try {
                        console.log(`‚ö° ${chain} Ï∫êÏãúÎêú RPC ÏÇ¨Ïö©: ${cachedRpc}`);
                        updateRpcStatus(`Ï∫êÏãúÎêú RPC Ïó∞Í≤∞ Ï§ë...`);

                        const testWeb3 = new Web3(cachedRpc);
                        const blockNumber = await Promise.race([
                            testWeb3.eth.getBlockNumber(),
                            new Promise((_, reject) => setTimeout(() => reject('timeout'), 1500))
                        ]);

                        web3 = testWeb3;
                        currentChain = chain;
                        currentRpcUrl = cachedRpc;

                        console.log(`‚úÖ ${chain} Ï∫êÏãú RPC Ïó∞Í≤∞ ÏÑ±Í≥µ (Î∏îÎ°ù: ${blockNumber})`);
                        updateRpcStatus(`‚úÖ Ïó∞Í≤∞ ÏÑ±Í≥µ: ${cachedRpc.replace('https://', '')}`, true);
                        updateProgressStep('step1', 'completed', '1. Î∏îÎ°ùÏ≤¥Ïù∏ Ïó∞Í≤∞ ÏôÑÎ£å');
                        return true;
                    } catch (e) {
                        console.warn(`Ï∫êÏãúÎêú RPC Ïã§Ìå®, ÏÉàÎ°ú ÌÉêÏÉâ...`);
                        delete rpcCache[chain];
                    }
                }

                let lastError = null;
                const maxRetries = Math.min(chainConfig.rpcs.length, 10);

                // Î≥ëÎ†¨Î°ú Ïó¨Îü¨ RPC ÎèôÏãú ÌÖåÏä§Ìä∏ (Í∞ÄÏû• Îπ†Î•∏ Í≤É ÏÑ†ÌÉù)
                const rpcTests = chainConfig.rpcs.slice(0, maxRetries).map(async (rpcUrl) => {
                    try {
                        const testWeb3 = new Web3(rpcUrl);
                        const start = Date.now();
                        const blockNumber = await Promise.race([
                            testWeb3.eth.getBlockNumber(),
                            new Promise((_, reject) => setTimeout(() => reject('timeout'), 1500))
                        ]);
                        const latency = Date.now() - start;
                        return { rpcUrl, testWeb3, blockNumber, latency };
                    } catch (e) {
                        return null;
                    }
                });

                updateRpcStatus(`${maxRetries}Í∞ú RPC ÎèôÏãú ÌÖåÏä§Ìä∏ Ï§ë...`);

                const results = await Promise.all(rpcTests);
                const validResults = results.filter(r => r !== null).sort((a, b) => a.latency - b.latency);

                if (validResults.length > 0) {
                    const fastest = validResults[0];
                    web3 = fastest.testWeb3;
                    currentChain = chain;
                    currentRpcUrl = fastest.rpcUrl;
                    rpcCache[chain] = fastest.rpcUrl; // Ï∫êÏãú Ï†ÄÏû•

                    console.log(`‚úÖ ${chain} ÏµúÍ≥†ÏÜç RPC: ${fastest.rpcUrl} (${fastest.latency}ms)`);
                    updateRpcStatus(`‚úÖ Ïó∞Í≤∞ ÏÑ±Í≥µ: ${fastest.rpcUrl.replace('https://', '')} (${fastest.latency}ms)`, true);
                    updateProgressStep('step1', 'completed', '1. Î∏îÎ°ùÏ≤¥Ïù∏ Ïó∞Í≤∞ ÏôÑÎ£å');
                    return true;
                }

                updateRpcStatus(`‚ùå Î™®Îì† ${chain} RPC ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïã§Ìå®`);
                throw new Error(`Î™®Îì† ${chain} RPC ÏÑúÎ≤Ñ Ïó∞Í≤∞ Ïã§Ìå®`);

            } catch (error) {
                updateProgressStep('step1', 'error', '1. Î∏îÎ°ùÏ≤¥Ïù∏ Ïó∞Í≤∞ Ïã§Ìå®');
                throw error;
            }
        }

        async function getTokenInfo(tokenAddress) {
            try {
                updateProgressStep('step2', 'active', '2. ÌÜ†ÌÅ∞ Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë...');

                if (tokenAddress === '0x0000000000000000000000000000000000000000') {
                    const result = CHAIN_CONFIG[currentChain].nativeToken;
                    updateProgressStep('step2', 'completed', '2. ÌÜ†ÌÅ∞ Ï†ïÎ≥¥ Ï°∞Ìöå ÏôÑÎ£å');
                    return result;
                }

                console.log('ÌÜ†ÌÅ∞ Ïª®Ìä∏ÎûôÌä∏ Ï°∞Ìöå: ' + tokenAddress);
                const contract = new web3.eth.Contract(ERC20_ABI, tokenAddress);

                let name = 'Unknown';
                let symbol = 'UNKNOWN';
                let decimals = 18;

                try {
                    name = await contract.methods.name().call();
                    console.log('ÌÜ†ÌÅ∞ Ïù¥Î¶Ñ: ' + name);
                } catch (e) {
                    console.warn('ÌÜ†ÌÅ∞ Ïù¥Î¶Ñ Ï°∞Ìöå Ïã§Ìå®:', e.message);
                }

                try {
                    symbol = await contract.methods.symbol().call();
                    console.log('ÌÜ†ÌÅ∞ Ïã¨Î≥º: ' + symbol);
                } catch (e) {
                    console.warn('ÌÜ†ÌÅ∞ Ïã¨Î≥º Ï°∞Ìöå Ïã§Ìå®:', e.message);
                }

                try {
                    decimals = await contract.methods.decimals().call();
                    decimals = parseInt(decimals);
                    console.log('ÌÜ†ÌÅ∞ ÏÜåÏàòÏ†ê: ' + decimals);
                } catch (e) {
                    console.warn('ÌÜ†ÌÅ∞ ÏÜåÏàòÏ†ê Ï°∞Ìöå Ïã§Ìå®, Í∏∞Î≥∏Í∞í 18 ÏÇ¨Ïö©:', e.message);
                    decimals = 18;
                }

                updateProgressStep('step2', 'completed', '2. ÌÜ†ÌÅ∞ Ï†ïÎ≥¥ Ï°∞Ìöå ÏôÑÎ£å');

                const result = {
                    name: name || 'Unknown',
                    symbol: symbol || 'UNKNOWN',
                    decimals: decimals
                };

                console.log('ÏµúÏ¢Ö ÌÜ†ÌÅ∞ Ï†ïÎ≥¥:', result);
                return result;

            } catch (error) {
                updateProgressStep('step2', 'error', '2. ÌÜ†ÌÅ∞ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®');
                console.error('ÌÜ†ÌÅ∞ Ï†ïÎ≥¥ Ï°∞Ìöå Ï†ÑÏ≤¥ Ïã§Ìå®:', error);
                throw new Error('ÌÜ†ÌÅ∞ Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®: ' + error.message);
            }
        }

        async function getTokenPrice(tokenAddress, chain) {
            try {
                updateProgressStep('step3', 'active', '3. Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï°∞Ìöå Ï§ë...');

                let geckoId = '';

                if (tokenAddress === '0x0000000000000000000000000000000000000000') {
                    geckoId = CHAIN_CONFIG[chain].geckoId;
                } else {
                    const platformMap = {
                        ETH: 'ethereum',
                        BSC: 'binance-smart-chain',
                        Polygon: 'polygon-pos',
                        Arbitrum: 'arbitrum-one',
                        Optimism: 'optimistic-ethereum',
                        Avalanche: 'avalanche'
                    };

                    const platform = platformMap[chain];
                    if (platform) {
                        const searchUrl = 'https://api.coingecko.com/api/v3/coins/' + platform + '/contract/' + tokenAddress;

                        try {
                            const response = await fetch(searchUrl);
                            if (response.ok) {
                                const tokenData = await response.json();
                                geckoId = tokenData.id;
                            }
                        } catch (e) {
                            console.log('ÌÜ†ÌÅ∞ Í≤ÄÏÉâ Ïã§Ìå®:', e);
                        }
                    }
                }

                if (geckoId) {
                    const priceUrl = 'https://api.coingecko.com/api/v3/simple/price?ids=' + geckoId + '&vs_currencies=usd&include_market_cap=true&include_24hr_change=true';
                    const response = await fetch(priceUrl);
                    const priceData = await response.json();

                    if (priceData[geckoId]) {
                        const detailUrl = 'https://api.coingecko.com/api/v3/coins/' + geckoId;
                        const detailResponse = await fetch(detailUrl);
                        const detailData = await detailResponse.json();

                        updateProgressStep('step3', 'completed', '3. Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï°∞Ìöå ÏôÑÎ£å');

                        return {
                            price: priceData[geckoId].usd || 0,
                            marketCap: priceData[geckoId].usd_market_cap || 0,
                            change24h: priceData[geckoId].usd_24h_change || 0,
                            fdv: detailData.market_data?.fully_diluted_valuation?.usd || priceData[geckoId].usd_market_cap || 0
                        };
                    }
                }

                updateProgressStep('step3', 'completed', '3. Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï°∞Ìöå ÏôÑÎ£å (Í∞ÄÍ≤© ÏóÜÏùå)');
                return null;
            } catch (error) {
                updateProgressStep('step3', 'error', '3. Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®');
                console.error('Í∞ÄÍ≤© Ï†ïÎ≥¥ Ï°∞Ìöå Ïã§Ìå®:', error);
                return null;
            }
        }

        async function getTokenBalanceWithWeb3(web3Instance, tokenAddress, walletData, decimals) {
            try {
                let correctedAddress;

                if (typeof walletData === 'object' && walletData.address) {
                    correctedAddress = walletData.address;
                } else if (Array.isArray(walletData)) {
                    console.warn('‚ö†Ô∏è Î∞∞Ïó¥ Ï£ºÏÜå Î∞úÍ≤¨:', walletData);
                    if (walletData.length === 0) {
                        console.warn('Îπà Î∞∞Ïó¥, Í±¥ÎÑàÎúÄ');
                        return 0;
                    }
                    correctedAddress = walletData[0];
                    console.log('üîÑ Î∞∞Ïó¥ÏóêÏÑú Ï≤´ Î≤àÏß∏ Ï£ºÏÜå ÏÇ¨Ïö©:', correctedAddress);
                } else {
                    correctedAddress = walletData;
                }

                if (typeof correctedAddress !== 'string') {
                    console.warn('Ï£ºÏÜåÍ∞Ä Î¨∏ÏûêÏó¥Ïù¥ ÏïÑÎãò:', typeof correctedAddress, correctedAddress);
                    return 0;
                }

                if (correctedAddress.includes(',')) {
                    console.warn('‚ö†Ô∏è Îã§Ï§ë Ï£ºÏÜå Î∞úÍ≤¨ (ÏâºÌëú Íµ¨Î∂Ñ):', correctedAddress);
                    const addresses = correctedAddress.split(',').map(addr => addr.trim());
                    correctedAddress = addresses[0];
                    console.log('üîÑ Îã§Ï§ë Ï£ºÏÜåÏóêÏÑú Ï≤´ Î≤àÏß∏ ÏÇ¨Ïö©:', correctedAddress);
                }

                try {
                    correctedAddress = web3Instance.utils.toChecksumAddress(correctedAddress);
                } catch (e) {
                    console.warn('Ï£ºÏÜå Ï≤¥ÌÅ¨ÏÑ¨ Î≥ÄÌôò Ïã§Ìå®:', correctedAddress, e.message);
                    return 0;
                }

                if (tokenAddress === '0x0000000000000000000000000000000000000000') {
                    const balance = await web3Instance.eth.getBalance(correctedAddress);
                    return parseFloat(web3Instance.utils.fromWei(balance, 'ether'));
                } else {
                    const contract = new web3Instance.eth.Contract(ERC20_ABI, tokenAddress);
                    const balance = await contract.methods.balanceOf(correctedAddress).call();

                    if (balance && balance !== '0') {
                        return parseFloat(balance) / Math.pow(10, decimals);
                    }
                    return 0;
                }
            } catch (error) {
                console.error('ÏûîÍ≥† Ï°∞Ìöå Ïã§Ìå® (' + walletAddress + '):', error);
                return 0;
            }
        }

        // SOL ÎÑ§Ïù¥Ìã∞Î∏å ÏûîÏï° Ï°∞Ìöå
        async function getSOLBalance(connection, walletAddress) {
            try {
                const publicKey = new solanaWeb3.PublicKey(walletAddress);
                const balance = await connection.getBalance(publicKey);
                return balance / 1e9; // lamports to SOL
            } catch (error) {
                console.error('SOL ÏûîÍ≥† Ï°∞Ìöå Ïã§Ìå®:', walletAddress, error);
                return 0;
            }
        }

        // SPL ÌÜ†ÌÅ∞ ÏûîÏï° Ï°∞Ìöå
        async function getSPLTokenBalance(connection, tokenMint, walletAddress) {
            try {
                const walletPubkey = new solanaWeb3.PublicKey(walletAddress);
                const mintPubkey = new solanaWeb3.PublicKey(tokenMint);

                // Token Account Ï∞æÍ∏∞ (Associated Token Account)
                const tokenAccounts = await connection.getParsedTokenAccountsByOwner(
                    walletPubkey,
                    { mint: mintPubkey }
                );

                if (tokenAccounts.value.length === 0) {
                    return 0;
                }

                let totalBalance = 0;
                for (const account of tokenAccounts.value) {
                    const amount = account.account.data.parsed.info.tokenAmount;
                    totalBalance += parseFloat(amount.uiAmount || 0);
                }

                return totalBalance;
            } catch (error) {
                console.error('SPL ÌÜ†ÌÅ∞ Ï°∞Ìöå Ïã§Ìå®:', walletAddress, error);
                return 0;
            }
        }

        // SOL ÏßÄÍ∞ëÎì§Ïùò ÏûîÏï° Î≥ëÎ†¨ Ï°∞Ìöå (ÏµúÏ†ÅÌôî: Î∞∞Ïπò + Î©ÄÌã∞ RPC + Ï∫êÏã±)
        async function getSOLBalancesParallel(tokenAddress, wallets) {
            updateProgressStep('step4', 'active', '4. SOL ÏßÄÍ∞ë ÏûîÍ≥† Ï°∞Ìöå Ï§ë...');

            const walletEntries = Object.entries(wallets);
            const rpcUrls = CHAIN_CONFIG['SOL'].rpcs;
            const isNativeSOL = tokenAddress === 'native' || tokenAddress === 'SOL' || tokenAddress === '';

            console.log(`üîÑ SOL RPC Ïó∞Í≤∞: ${walletEntries.length}Í∞ú ÏßÄÍ∞ë`);

            let connections = [];

            // Ï∫êÏãúÎêú SOL Ïó∞Í≤∞Ïù¥ ÏûàÏúºÎ©¥ Î®ºÏ†Ä ÏÇ¨Ïö©
            if (solConnectionCache.connections && solConnectionCache.connections.length > 0) {
                console.log(`‚ö° Ï∫êÏãúÎêú SOL RPC ${solConnectionCache.connections.length}Í∞ú ÏÇ¨Ïö©`);
                // Ï∫êÏãúÎêú Ïó∞Í≤∞ Ïú†Ìö®ÏÑ± Îπ†Î•∏ Ï≤¥ÌÅ¨
                try {
                    await Promise.race([
                        solConnectionCache.connections[0].connection.getSlot(),
                        new Promise((_, reject) => setTimeout(() => reject('timeout'), 1500))
                    ]);
                    connections = solConnectionCache.connections;
                } catch (e) {
                    console.warn('Ï∫êÏãúÎêú SOL Ïó∞Í≤∞ ÎßåÎ£å, ÏÉàÎ°ú ÌÉêÏÉâ...');
                    solConnectionCache.connections = null;
                }
            }

            // Ï∫êÏãú ÏóÜÍ±∞ÎÇò ÎßåÎ£åÎêêÏúºÎ©¥ ÏÉàÎ°ú Ïó∞Í≤∞
            if (connections.length === 0) {
                const connectionTests = rpcUrls.map(async (rpcUrl) => {
                    try {
                        const conn = new solanaWeb3.Connection(rpcUrl, {
                            commitment: 'confirmed',
                            confirmTransactionInitialTimeout: 5000
                        });
                        const start = Date.now();
                        await Promise.race([
                            conn.getSlot(),
                            new Promise((_, reject) => setTimeout(() => reject('timeout'), 1500))
                        ]);
                        const latency = Date.now() - start;
                        return { connection: conn, url: rpcUrl, latency };
                    } catch (e) {
                        return null;
                    }
                });

                const connectionResults = await Promise.all(connectionTests);
                connections = connectionResults.filter(c => c !== null).sort((a, b) => a.latency - b.latency);

                if (connections.length === 0) {
                    throw new Error('Î™®Îì† SOL RPC Ïó∞Í≤∞ Ïã§Ìå®');
                }

                // Ï∫êÏãú Ï†ÄÏû•
                solConnectionCache.connections = connections;
            }

            console.log(`‚úÖ ${connections.length}Í∞ú SOL RPC ÏÇ¨Ïö©`);

            const finalResults = {};
            let totalCompleted = 0;

            if (isNativeSOL) {
                // ÎÑ§Ïù¥Ìã∞Î∏å SOL: getMultipleAccountsInfoÎ°ú Î∞∞Ïπò Ï°∞Ìöå
                const BATCH_SIZE = 100; // Solana ÏµúÎåÄ 100Í∞ú
                const batches = [];

                for (let i = 0; i < walletEntries.length; i += BATCH_SIZE) {
                    batches.push(walletEntries.slice(i, i + BATCH_SIZE));
                }

                console.log(`üì¶ ${batches.length}Í∞ú Î∞∞ÏπòÎ°ú Î∂ÑÌï† (Î∞∞ÏπòÎãπ ÏµúÎåÄ ${BATCH_SIZE}Í∞ú)`);

                // Î∞∞ÏπòÎ•º RPCÏóê Î∂ÑÏÇ∞
                const batchPromises = batches.map(async (batch, batchIndex) => {
                    const connInfo = connections[batchIndex % connections.length];
                    const connection = connInfo.connection;

                    try {
                        const publicKeys = batch.map(([name, walletData]) => {
                            const address = typeof walletData === 'object' ? walletData.address : walletData;
                            return new solanaWeb3.PublicKey(address);
                        });

                        const accountInfos = await connection.getMultipleAccountsInfo(publicKeys);

                        const batchResults = {};
                        batch.forEach(([name, walletData], idx) => {
                            const accountInfo = accountInfos[idx];
                            const balance = accountInfo ? accountInfo.lamports / 1e9 : 0;
                            batchResults[name] = balance;
                        });

                        totalCompleted += batch.length;
                        const progress = Math.round((totalCompleted / walletEntries.length) * 100);
                        updateProgressStep('step4', 'active', `4. SOL ÏßÄÍ∞ë ÏûîÍ≥† Ï°∞Ìöå Ï§ë... (${totalCompleted}/${walletEntries.length}) ${progress}%`);

                        return batchResults;
                    } catch (error) {
                        console.error(`Î∞∞Ïπò ${batchIndex + 1} Ï°∞Ìöå Ïã§Ìå®:`, error);
                        // Ïã§Ìå® Ïãú Í∞úÎ≥Ñ Ï°∞ÌöåÎ°ú Ìè¥Î∞±
                        const batchResults = {};
                        for (const [name, walletData] of batch) {
                            try {
                                const address = typeof walletData === 'object' ? walletData.address : walletData;
                                const balance = await getSOLBalance(connection, address);
                                batchResults[name] = balance;
                            } catch (e) {
                                batchResults[name] = 0;
                            }
                        }
                        totalCompleted += batch.length;
                        return batchResults;
                    }
                });

                const batchResultsArray = await Promise.all(batchPromises);
                batchResultsArray.forEach(batchResult => {
                    Object.assign(finalResults, batchResult);
                });

            } else {
                // SPL ÌÜ†ÌÅ∞: RPC Î∂ÑÏÇ∞ Î≥ëÎ†¨ Ï≤òÎ¶¨
                const groupSize = Math.ceil(walletEntries.length / connections.length);
                const groups = [];

                for (let i = 0; i < connections.length && i * groupSize < walletEntries.length; i++) {
                    groups.push({
                        wallets: walletEntries.slice(i * groupSize, (i + 1) * groupSize),
                        connection: connections[i].connection,
                        rpcUrl: connections[i].url
                    });
                }

                console.log(`üöÄ ${groups.length}Í∞ú RPCÎ°ú SPL ÌÜ†ÌÅ∞ Î≥ëÎ†¨ Ï°∞Ìöå`);

                const groupPromises = groups.map(async (group, groupIndex) => {
                    const groupResults = {};

                    const walletPromises = group.wallets.map(async ([name, walletData]) => {
                        const address = typeof walletData === 'object' ? walletData.address : walletData;
                        try {
                            const balance = await getSPLTokenBalance(group.connection, tokenAddress, address);
                            totalCompleted++;
                            const progress = Math.round((totalCompleted / walletEntries.length) * 100);
                            updateProgressStep('step4', 'active', `4. SOL ÏßÄÍ∞ë ÏûîÍ≥† Ï°∞Ìöå Ï§ë... (${totalCompleted}/${walletEntries.length}) ${progress}%`);
                            return [name, balance];
                        } catch (error) {
                            totalCompleted++;
                            return [name, 0];
                        }
                    });

                    const results = await Promise.all(walletPromises);
                    results.forEach(([name, balance]) => {
                        groupResults[name] = balance;
                    });

                    return groupResults;
                });

                const groupResultsArray = await Promise.all(groupPromises);
                groupResultsArray.forEach(groupResult => {
                    Object.assign(finalResults, groupResult);
                });
            }

            updateProgressStep('step4', 'completed', '4. SOL ÏßÄÍ∞ë ÏûîÍ≥† Ï°∞Ìöå ÏôÑÎ£å!');
            console.log(`üéâ SOL Ï°∞Ìöå ÏôÑÎ£å! ${Object.keys(finalResults).length}Í∞ú ÏßÄÍ∞ë`);

            return finalResults;
        }

        // MulticallÎ°ú Î∞∞Ïπò ÏûîÍ≥† Ï°∞Ìöå (1Î≤à ÏöîÏ≤≠ = ÏµúÎåÄ 100Í∞ú ÏßÄÍ∞ë)
        async function getBalancesParallel(tokenAddress, wallets, decimals) {
            updateProgressStep('step4', 'active', '4. Multicall Î∞∞Ïπò Ï°∞Ìöå Ï§ë...');

            const walletEntries = Object.entries(wallets);
            const isNative = tokenAddress === '0x0000000000000000000000000000000000000000';

            console.log(`‚ö° Multicall Î∞∞Ïπò Ï°∞Ìöå: ${walletEntries.length}Í∞ú ÏßÄÍ∞ë`);

            const BATCH_SIZE = 100;
            const batches = [];
            for (let i = 0; i < walletEntries.length; i += BATCH_SIZE) {
                batches.push(walletEntries.slice(i, i + BATCH_SIZE));
            }

            console.log(`üì¶ ${batches.length}Í∞ú Î∞∞Ïπò ÏÉùÏÑ± (Î∞∞ÏπòÎãπ ÏµúÎåÄ ${BATCH_SIZE}Í∞ú)`);

            const finalResults = {};
            let totalCompleted = 0;
            let totalErrors = 0;

            // Ïó¨Îü¨ RPCÎ°ú Î∞∞Ïπò Î∂ÑÏÇ∞
            const rpcUrls = CHAIN_CONFIG[currentChain].rpcs;

            const batchPromises = batches.map(async (batch, batchIndex) => {
                const rpcUrl = rpcCache[currentChain] || rpcUrls[batchIndex % rpcUrls.length];

                try {
                    const batchWeb3 = new Web3(rpcUrl);
                    const multicall = new batchWeb3.eth.Contract(MULTICALL3_ABI, MULTICALL3_ADDRESS);

                    // balanceOf Ìò∏Ï∂ú Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
                    const calls = batch.map(([name, walletData]) => {
                        const address = typeof walletData === 'object' ? walletData.address : walletData;

                        if (isNative) {
                            // ÎÑ§Ïù¥Ìã∞Î∏å ÌÜ†ÌÅ∞: getEthBalance Ìò∏Ï∂ú
                            const callData = batchWeb3.eth.abi.encodeFunctionCall({
                                name: 'getEthBalance',
                                type: 'function',
                                inputs: [{ type: 'address', name: 'addr' }]
                            }, [address]);
                            return { target: MULTICALL3_ADDRESS, allowFailure: true, callData };
                        } else {
                            // ERC20: balanceOf Ìò∏Ï∂ú
                            const callData = batchWeb3.eth.abi.encodeFunctionCall({
                                name: 'balanceOf',
                                type: 'function',
                                inputs: [{ type: 'address', name: '_owner' }],
                                outputs: [{ type: 'uint256', name: 'balance' }]
                            }, [address]);
                            return { target: tokenAddress, allowFailure: true, callData };
                        }
                    });

                    const results = await Promise.race([
                        multicall.methods.aggregate3(calls).call(),
                        new Promise((_, reject) => setTimeout(() => reject('timeout'), 5000))
                    ]);

                    const batchResults = {};
                    batch.forEach(([name, walletData], idx) => {
                        try {
                            if (results[idx].success) {
                                const rawBalance = batchWeb3.eth.abi.decodeParameter('uint256', results[idx].returnData);
                                const balance = parseFloat(rawBalance) / Math.pow(10, decimals);
                                if (balance > 0) {
                                    batchResults[name] = balance;
                                }
                            }
                        } catch (e) {
                            totalErrors++;
                        }
                    });

                    totalCompleted += batch.length;
                    const progress = Math.round((totalCompleted / walletEntries.length) * 100);
                    updateProgressStep('step4', 'active', `4. Multicall Î∞∞Ïπò Ï°∞Ìöå Ï§ë... (${totalCompleted}/${walletEntries.length}) ${progress}%`);

                    console.log(`‚úÖ Î∞∞Ïπò${batchIndex + 1} ÏôÑÎ£å: ${Object.keys(batchResults).length}Í∞ú Î∞úÍ≤¨`);
                    return batchResults;

                } catch (error) {
                    console.warn(`‚ö†Ô∏è Î∞∞Ïπò${batchIndex + 1} Multicall Ïã§Ìå®, Í∞úÎ≥Ñ Ï°∞ÌöåÎ°ú Ìè¥Î∞±:`, error.message?.substring(0, 50));

                    // Ìè¥Î∞±: Í∞úÎ≥Ñ Ï°∞Ìöå
                    const batchResults = {};
                    const batchWeb3 = new Web3(rpcUrl);

                    for (const [name, walletData] of batch) {
                        try {
                            const address = typeof walletData === 'object' ? walletData.address : walletData;
                            const balance = await getTokenBalanceWithWeb3(batchWeb3, tokenAddress, address, decimals);
                            if (balance > 0) batchResults[name] = balance;
                        } catch (e) {
                            totalErrors++;
                        }
                        totalCompleted++;
                    }

                    return batchResults;
                }
            });

            const batchResultsArray = await Promise.all(batchPromises);
            batchResultsArray.forEach(batchResult => {
                Object.assign(finalResults, batchResult);
            });

            console.log(`üéâ Multicall ÏôÑÎ£å! ${Object.keys(finalResults).length}Í∞ú ÏßÄÍ∞ë Î∞úÍ≤¨ (${totalErrors}Í∞ú ÏóêÎü¨)`);
            updateProgressStep('step4', 'completed', `4. ÏûîÍ≥† Ï°∞Ìöå ÏôÑÎ£å (${totalErrors}Í∞ú ÏóêÎü¨)`);

            return finalResults;
        }

        function displayTokenInfo(tokenInfo, contractAddress) {
            currentTokenAddress = contractAddress;
            document.getElementById('contractAddress').textContent = contractAddress;
            document.getElementById('tokenName').textContent = tokenInfo.name;
            document.getElementById('tokenSymbol').textContent = tokenInfo.symbol;
            document.getElementById('currentChainDisplay').innerHTML =
                CHAIN_CONFIG[currentChain].name + ' <span class="chain-badge ' + currentChain.toLowerCase() + '">' + CHAIN_CONFIG[currentChain].nativeToken.symbol + '</span>';
        }

        function displayPriceInfo(priceInfo) {
            if (priceInfo) {
                document.getElementById('tokenPrice').textContent =
                    priceInfo.price < 0.01 ? '$' + priceInfo.price.toFixed(8) : '$' + priceInfo.price.toFixed(2);
                document.getElementById('priceChange').innerHTML =
                    (priceInfo.change24h > 0 ? 'üü¢' : 'üî¥') + ' ' + priceInfo.change24h.toFixed(2) + '%';
                document.getElementById('marketCap').textContent =
                    '$' + formatNumber(priceInfo.marketCap);
                document.getElementById('fdv').textContent =
                    '$' + formatNumber(priceInfo.fdv);
            } else {
                document.getElementById('tokenPrice').textContent = 'Í∞ÄÍ≤© Ï†ïÎ≥¥ ÏóÜÏùå';
                document.getElementById('priceChange').textContent = '-';
                document.getElementById('marketCap').textContent = '-';
                document.getElementById('fdv').textContent = '-';
            }
        }

        function displayBalances(balances, tokenPrice = 0) {
            if (Object.keys(balances).length === 0) {
                showMessage('warning', 'Í±∞ÎûòÏÜåÏóêÏÑú Ìï¥Îãπ ÌÜ†ÌÅ∞ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
                return;
            }

            const sortedBalances = Object.entries(balances).sort((a, b) => b[1] - a[1]);
            const totalBalance = sortedBalances.reduce((sum, [name, balance]) => sum + balance, 0);

            document.getElementById('totalBalance').textContent = formatNumber(totalBalance);
            document.getElementById('totalValue').textContent = '$' + formatNumber(totalBalance * tokenPrice);

            updateChart(sortedBalances, totalBalance);
            fillTable(sortedBalances);

            showMessage('success', 'Ï¥ù ' + Object.keys(balances).length + 'Í∞ú Í±∞ÎûòÏÜåÏóêÏÑú ÌÜ†ÌÅ∞ÏùÑ Î∞úÍ≤¨ÌñàÏäµÎãàÎã§!');

            // Ïã§ÏãúÍ∞Ñ Ï∂úÍ∏à Î™®ÎãàÌÑ∞ÎßÅ ÏãúÏûë (WebSocket logs Íµ¨ÎèÖ)
            startWithdrawalMonitoring(sortedBalances);
        }

        function updateChart(balances, total) {
            const ctx = document.getElementById('chartCanvas').getContext('2d');

            const labels = [];
            const data = [];
            const colors = [];

            const displayBalances = balances.slice(0, 10);

            displayBalances.forEach(([name, balance]) => {
                labels.push(name);
                data.push(balance);
                colors.push(getRandomColor());
            });

            if (!chart) {
                chart = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: data,
                            backgroundColor: colors,
                            borderWidth: 2,
                            borderColor: '#1a1f2e'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'right',
                                labels: {
                                    color: '#ffffff',
                                    generateLabels: function(chart) {
                                        const data = chart.data;
                                        if (data.labels.length && data.datasets.length) {
                                            return data.labels.map((label, i) => {
                                                const value = data.datasets[0].data[i];
                                                const percentage = ((value / total) * 100).toFixed(1);
                                                return {
                                                    text: label + ': ' + formatNumber(value) + ' (' + percentage + '%)',
                                                    fillStyle: data.datasets[0].backgroundColor[i],
                                                    strokeStyle: data.datasets[0].backgroundColor[i],
                                                    fontColor: '#ffffff',
                                                    index: i
                                                };
                                            });
                                        }
                                        return [];
                                    }
                                }
                            },
                            title: {
                                display: true,
                                text: currentChain + ' - Token Distribution',
                                color: '#ffffff',
                                font: { size: 16 }
                            }
                        }
                    }
                });
            } else {
                chart.data.labels = labels;
                chart.data.datasets[0].data = data;
                chart.data.datasets[0].backgroundColor = colors;
                chart.update();
            }
        }

        function fillTable(balances) {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';

            const explorerUrl = CHAIN_CONFIG[currentChain].explorer;
            const isSOL = currentChain === 'SOL';

            balances.forEach(([name, balance], index) => {
                // SOLÏù¥Î©¥ SOL ÏßÄÍ∞ëÏóêÏÑú, ÏïÑÎãàÎ©¥ EVM ÏßÄÍ∞ëÏóêÏÑú Í∞ÄÏ†∏Ïò¥
                const walletSource = isSOL ? (wallets.SOL || {}) : (wallets.EVM || {});
                const walletData = walletSource[name];
                let address = 'Ï£ºÏÜå ÏóÜÏùå';
                if (typeof walletData === 'object' && walletData.address) {
                    address = walletData.address;
                } else if (walletData) {
                    address = walletData;
                }

                let scanUrl = '#';
                if (address !== 'Ï£ºÏÜå ÏóÜÏùå') {
                    if (isSOL) {
                        // Solscan URL - Ìè¨Ìä∏Ìè¥Î¶¨Ïò§ ÌÉ≠ÏúºÎ°ú Ïù¥Îèô
                        scanUrl = `${explorerUrl}/account/${address}#portfolio`;
                    } else if (currentTokenAddress === '0x0000000000000000000000000000000000000000') {
                        scanUrl = `${explorerUrl}/address/${address}`;
                    } else {
                        scanUrl = `${explorerUrl}/token/${currentTokenAddress}?a=${address}`;
                    }
                }

                const safeName = name.replace(/[^a-zA-Z0-9]/g, '_');
                const withdrawalCellId = `withdrawal-${safeName}`;
                const timeCellId = `time-${safeName}`;

                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${name}</td>
                    <td class="address-cell">
                        ${address !== 'Ï£ºÏÜå ÏóÜÏùå' ?
                            `<div class="address-clickable" onclick="copyToClipboard('${address}', this)">
                                ${address}
                                <div class="copy-tooltip">Î≥µÏÇ¨Îê®!</div>
                            </div>` :
                            '<span style="color: #666;">Ï£ºÏÜå ÏóÜÏùå</span>'
                        }
                    </td>
                    <td><strong>${formatNumber(balance)}</strong></td>
                    <td id="${withdrawalCellId}"><span style="color: #666;">-</span></td>
                    <td id="${timeCellId}"><span style="color: #666;">-</span></td>
                    <td>
                        ${address !== 'Ï£ºÏÜå ÏóÜÏùå' ?
                            '<a href="' + scanUrl + '" target="_blank" class="explorer-btn">Î≥¥Í∏∞</a>' :
                            '<span style="color: #666; font-size: 11px;">-</span>'
                        }
                    </td>
                `;
            });
        }

        function resetResults() {
            document.getElementById('tokenName').textContent = '-';
            document.getElementById('tokenSymbol').textContent = '-';
            document.getElementById('currentChainDisplay').textContent = '-';
            document.getElementById('contractAddress').textContent = '-';
            document.getElementById('tokenPrice').textContent = '-';
            document.getElementById('priceChange').textContent = '-';
            document.getElementById('marketCap').textContent = '-';
            document.getElementById('fdv').textContent = '-';
            document.getElementById('totalBalance').textContent = '0';
            document.getElementById('totalValue').textContent = '$0';
            document.getElementById('tableBody').innerHTML = '';
        }

        async function searchToken() {
            if (isSearching) {
                showMessage('warning', 'Ïù¥ÎØ∏ Í≤ÄÏÉâ Ï§ëÏûÖÎãàÎã§. Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî.');
                return;
            }

            const chain = document.getElementById('chainSelect').value;
            const input = document.getElementById('tokenInput').value.trim();

            if (!input) {
                showMessage('error', 'ÌÜ†ÌÅ∞ Ï£ºÏÜåÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
                return;
            }

            isSearching = true;
            stopWithdrawalMonitoring();
            withdrawalCache = {};
            Object.keys(lastSeenWithdrawalTx).forEach(k => delete lastSeenWithdrawalTx[k]);
            hideMessage('error');
            hideMessage('warning');
            hideMessage('success');

            document.getElementById('detailedProgress').style.display = 'block';
            document.getElementById('results').style.display = 'block';
            resetResults();

            let tokenAddress = input;
            const isSOL = chain === 'SOL';

            if (isSOL) {
                // SOL Ï≤¥Ïù∏: native ÎòêÎäî SPL ÌÜ†ÌÅ∞ Ï£ºÏÜå
                if (input.toUpperCase() === 'SOL' || input === '') {
                    tokenAddress = 'native';
                }
            } else {
                // EVM Ï≤¥Ïù∏
                if (!input.startsWith('0x')) {
                    const chainConfig = CHAIN_CONFIG[chain];
                    const nativeSymbols = [chainConfig.nativeToken.symbol, chainConfig.name.toUpperCase()];

                    if (nativeSymbols.includes(input.toUpperCase())) {
                        tokenAddress = '0x0000000000000000000000000000000000000000';
                    } else {
                        showMessage('error', input + ' ÌÜ†ÌÅ∞Ïùò Ïª®Ìä∏ÎûôÌä∏ Ï£ºÏÜåÎ•º ÏßÅÏ†ë ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
                        isSearching = false;
                        document.getElementById('detailedProgress').style.display = 'none';
                        return;
                    }
                }
            }

            try {
                console.log('üîç ' + chain + ' Ï≤¥Ïù∏ÏóêÏÑú ' + tokenAddress + ' Í≤ÄÏÉâ ÏãúÏûë');

                const selectedRegion = document.getElementById('regionSelect').value;

                if (isSOL) {
                    // SOL Ï≤¥Ïù∏ Ï≤òÎ¶¨
                    currentChain = 'SOL';  // Ï§ëÏöî: currentChain ÏÑ§Ï†ï
                    updateProgressStep('step1', 'active', '1. SOL RPC Ïó∞Í≤∞ Ï§ë...');

                    const allWallets = wallets.SOL || {};

                    let chainWallets = {};
                    for (const [name, walletData] of Object.entries(allWallets)) {
                        let walletRegion = 'FOREIGN';
                        if (typeof walletData === 'object' && walletData.region) {
                            walletRegion = walletData.region;
                        }
                        if (selectedRegion === 'ALL' || walletRegion === selectedRegion) {
                            chainWallets[name] = walletData;
                        }
                    }

                    const totalCount = Object.keys(allWallets).length;
                    const filteredCount = Object.keys(chainWallets).length;
                    console.log(`üìä SOL Region ÌïÑÌÑ∞: ${selectedRegion} (${filteredCount}/${totalCount}Í∞ú ÏßÄÍ∞ë)`);

                    if (Object.keys(chainWallets).length === 0) {
                        throw new Error(`${selectedRegion} ÏßÄÏó≠Ïóê Îì±Î°ùÎêú SOL ÏßÄÍ∞ëÏù¥ ÏóÜÏäµÎãàÎã§.`);
                    }

                    updateProgressStep('step1', 'completed', '1. SOL RPC Ïó∞Í≤∞ ÏôÑÎ£å!');

                    // SOL ÌÜ†ÌÅ∞ Ï†ïÎ≥¥
                    const isNativeSOL = tokenAddress === 'native';
                    let tokenInfo;

                    if (isNativeSOL) {
                        tokenInfo = { name: 'Solana', symbol: 'SOL', decimals: 9 };
                        updateProgressStep('step2', 'completed', '2. SOL ÎÑ§Ïù¥Ìã∞Î∏å ÌÜ†ÌÅ∞');
                    } else {
                        tokenInfo = { name: 'SPL Token', symbol: 'SPL', decimals: 9, address: tokenAddress };
                        updateProgressStep('step2', 'completed', '2. SPL ÌÜ†ÌÅ∞ Ï†ïÎ≥¥ ÌôïÏù∏');
                    }

                    displayTokenInfo(tokenInfo, tokenAddress);
                    document.getElementById('progressSection').style.display = 'block';

                    // Í∞ÄÍ≤© Ï°∞Ìöå + ÏûîÍ≥† Ï°∞Ìöå ÎèôÏãú Ïã§Ìñâ
                    const [priceInfo, balances] = await Promise.all([
                        getTokenPrice(tokenAddress === 'native' ? 'solana' : tokenAddress, 'SOL'),
                        getSOLBalancesParallel(tokenAddress, chainWallets)
                    ]);

                    displayPriceInfo(priceInfo);
                    displayBalances(balances, priceInfo ? priceInfo.price : 0);

                } else {
                    // EVM Ï≤¥Ïù∏ Ï≤òÎ¶¨ (ÏµúÏ†ÅÌôî: RPCÏó∞Í≤∞ + Í∞ÄÍ≤©Ï°∞Ìöå ÎèôÏãú ÏãúÏûë)
                    const pricePromise = getTokenPrice(tokenAddress, chain); // Í∞ÄÍ≤©ÏùÄ RPC ÌïÑÏöîÏóÜÏùå, Î®ºÏ†Ä ÏãúÏûë

                    await connectToChain(chain);

                    const [tokenInfo, priceInfo] = await Promise.all([
                        getTokenInfo(tokenAddress),
                        pricePromise // Ïù¥ÎØ∏ ÏãúÏûëÎêú Í∞ÄÍ≤© Ï°∞Ìöå
                    ]);

                    currentTokenDecimals = tokenInfo.decimals || 18;

                    displayTokenInfo(tokenInfo, tokenAddress);
                    displayPriceInfo(priceInfo);

                    const allWallets = wallets.EVM || {};

                    let chainWallets = {};
                    for (const [name, walletData] of Object.entries(allWallets)) {
                        let walletRegion = 'FOREIGN';
                        if (typeof walletData === 'object' && walletData.region) {
                            walletRegion = walletData.region;
                        }

                        if (selectedRegion === 'ALL' || walletRegion === selectedRegion) {
                            chainWallets[name] = walletData;
                        }
                    }

                    const totalCount = Object.keys(allWallets).length;
                    const filteredCount = Object.keys(chainWallets).length;
                    console.log(`üìä Region ÌïÑÌÑ∞: ${selectedRegion} (${filteredCount}/${totalCount}Í∞ú ÏßÄÍ∞ë)`);

                    if (Object.keys(chainWallets).length === 0) {
                        throw new Error(`${selectedRegion} ÏßÄÏó≠Ïóê Îì±Î°ùÎêú EVM ÏßÄÍ∞ëÏù¥ ÏóÜÏäµÎãàÎã§.`);
                    }

                    document.getElementById('progressSection').style.display = 'block';

                    const balances = await getBalancesParallel(
                        tokenAddress,
                        chainWallets,
                        tokenInfo.decimals
                    );

                    displayBalances(balances, priceInfo ? priceInfo.price : 0);
                }

                setTimeout(() => {
                    document.getElementById('progressSection').style.display = 'none';
                    document.getElementById('detailedProgress').style.display = 'none';
                }, 2000);

            } catch (error) {
                console.error('‚ùå Í≤ÄÏÉâ Ïò§Î•ò:', error);

                let errorMessage = 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.';

                if (error.message.includes('Ïó∞Í≤∞')) {
                    errorMessage = chain + ' Î∏îÎ°ùÏ≤¥Ïù∏ Ïó∞Í≤∞Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.';
                } else if (error.message.includes('ÌÜ†ÌÅ∞ Ï†ïÎ≥¥')) {
                    errorMessage = 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ÌÜ†ÌÅ∞ Ï£ºÏÜåÏûÖÎãàÎã§. Ïª®Ìä∏ÎûôÌä∏ Ï£ºÏÜåÎ•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.';
                } else if (error.message.includes('ÏßÄÍ∞ë')) {
                    errorMessage = chain + ' Ï≤¥Ïù∏Ïóê Îì±Î°ùÎêú ÏßÄÍ∞ëÏù¥ ÏóÜÏäµÎãàÎã§. ÏßÄÍ∞ëÏùÑ Î®ºÏ†Ä Ï∂îÍ∞ÄÌï¥Ï£ºÏÑ∏Ïöî.';
                } else {
                    errorMessage = error.message;
                }

                showMessage('error', errorMessage);
                document.getElementById('detailedProgress').style.display = 'none';
            } finally {
                isSearching = false;
            }
        }

        function displayWallets() {
            const walletList = document.getElementById('walletList');
            walletList.innerHTML = '';

            const evmWallets = wallets.EVM || {};
            const solWallets = wallets.SOL || {};
            const evmCount = Object.keys(evmWallets).length;
            const solCount = Object.keys(solWallets).length;

            const countDiv = document.createElement('div');
            countDiv.style.marginBottom = '10px';
            countDiv.style.color = '#aaa';
            countDiv.textContent = `Ï¥ù ${evmCount}Í∞ú EVM, ${solCount}Í∞ú SOL ÏßÄÍ∞ëÏù¥ Îì±Î°ùÎêòÏñ¥ ÏûàÏäµÎãàÎã§.`;
            walletList.appendChild(countDiv);

            // EVM ÏßÄÍ∞ë ÌëúÏãú
            Object.entries(evmWallets).forEach(([name, walletData]) => {
                let displayAddress;
                let region = 'FOREIGN';
                let isArrayAddress = false;

                if (typeof walletData === 'object' && walletData.address) {
                    displayAddress = walletData.address;
                    region = walletData.region || 'FOREIGN';
                } else if (Array.isArray(walletData)) {
                    displayAddress = walletData.length > 0 ? walletData[0] : 'Îπà Î∞∞Ïó¥';
                    isArrayAddress = true;
                } else {
                    displayAddress = walletData;
                }

                const regionBadge = region === 'DOMESTIC'
                    ? '<span style="background: #4CAF50; padding: 2px 6px; border-radius: 8px; font-size: 9px; margin-left: 5px;">Íµ≠ÎÇ¥</span>'
                    : '<span style="background: #2196F3; padding: 2px 6px; border-radius: 8px; font-size: 9px; margin-left: 5px;">Ìï¥Ïô∏</span>';

                const item = document.createElement('div');
                item.className = 'wallet-item';
                item.innerHTML = `
                    <span>
                        <span class="chain-badge" style="background: #627EEA;">EVM</span>
                        ${regionBadge}
                        ${name}: ${displayAddress}
                        ${isArrayAddress ? '<span style="color: #ff9800; font-size: 10px;">[Î∞∞Ïó¥]</span>' : ''}
                    </span>
                    <div class="wallet-actions">
                        <button class="edit-btn" onclick="editWallet('${name}', 'EVM')">Ìé∏Ïßë</button>
                        <button class="delete-btn" onclick="deleteWallet('${name}', 'EVM')">ÏÇ≠Ï†ú</button>
                    </div>
                `;
                walletList.appendChild(item);
            });

            // SOL ÏßÄÍ∞ë ÌëúÏãú
            Object.entries(solWallets).forEach(([name, walletData]) => {
                let displayAddress;
                let region = 'FOREIGN';

                if (typeof walletData === 'object' && walletData.address) {
                    displayAddress = walletData.address;
                    region = walletData.region || 'FOREIGN';
                } else {
                    displayAddress = walletData;
                }

                const regionBadge = region === 'DOMESTIC'
                    ? '<span style="background: #4CAF50; padding: 2px 6px; border-radius: 8px; font-size: 9px; margin-left: 5px;">Íµ≠ÎÇ¥</span>'
                    : '<span style="background: #2196F3; padding: 2px 6px; border-radius: 8px; font-size: 9px; margin-left: 5px;">Ìï¥Ïô∏</span>';

                const item = document.createElement('div');
                item.className = 'wallet-item';
                item.innerHTML = `
                    <span>
                        <span class="chain-badge" style="background: #9945FF;">SOL</span>
                        ${regionBadge}
                        ${name}: ${displayAddress}
                    </span>
                    <div class="wallet-actions">
                        <button class="edit-btn" onclick="editWallet('${name}', 'SOL')">Ìé∏Ïßë</button>
                        <button class="delete-btn" onclick="deleteWallet('${name}', 'SOL')">ÏÇ≠Ï†ú</button>
                    </div>
                `;
                walletList.appendChild(item);
            });
        }

        let editingChainType = 'EVM';

        function editWallet(name, chainType = 'EVM') {
            editingWallet = name;
            editingChainType = chainType;

            let walletData = chainType === 'SOL' ? wallets.SOL[name] : wallets.EVM[name];
            let address = '';
            let region = 'FOREIGN';

            if (typeof walletData === 'object' && walletData.address) {
                address = walletData.address;
                region = walletData.region || 'FOREIGN';
            } else if (Array.isArray(walletData)) {
                address = walletData.length > 0 ? walletData[0] : '';
            } else {
                address = walletData || '';
            }

            document.getElementById('walletChainType').value = chainType;
            document.getElementById('walletName').value = name;
            document.getElementById('walletAddress').value = address;
            document.getElementById('walletRegion').value = region;

            const actionBtn = document.getElementById('walletActionBtn');
            const cancelBtn = document.getElementById('walletCancelBtn');

            actionBtn.textContent = 'ÏàòÏ†ï ÏôÑÎ£å';
            actionBtn.onclick = updateWallet;
            actionBtn.style.background = '#2196F3';

            cancelBtn.style.display = 'inline-block';

            document.getElementById('walletName').focus();

            showMessage('success', chainType + ' - ' + name + ' ÏßÄÍ∞ëÏùÑ Ìé∏Ïßë Ï§ëÏûÖÎãàÎã§. ÏàòÏ†ï ÌõÑ "ÏàòÏ†ï ÏôÑÎ£å"Î•º ÌÅ¥Î¶≠ÌïòÏÑ∏Ïöî.');
        }

        function cancelEdit() {
            editingWallet = null;

            document.getElementById('walletName').value = '';
            document.getElementById('walletAddress').value = '';
            document.getElementById('walletRegion').value = 'FOREIGN';

            const actionBtn = document.getElementById('walletActionBtn');
            const cancelBtn = document.getElementById('walletCancelBtn');

            actionBtn.textContent = 'Ï∂îÍ∞Ä';
            actionBtn.onclick = addWallet;
            actionBtn.style.background = '#3b4252';

            cancelBtn.style.display = 'none';

            showMessage('success', 'Ìé∏ÏßëÏù¥ Ï∑®ÏÜåÎêòÏóàÏäµÎãàÎã§.');
        }

        async function updateWallet() {
            const newName = document.getElementById('walletName').value.trim();
            let newAddress = document.getElementById('walletAddress').value.trim();
            const newRegion = document.getElementById('walletRegion').value;

            if (!newName || !newAddress) {
                showMessage('error', 'Í±∞ÎûòÏÜåÎ™ÖÍ≥º Ï£ºÏÜåÎ•º Î™®Îëê ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
                return;
            }

            if (editingChainType === 'EVM') {
                if (!newAddress.startsWith('0x')) {
                    newAddress = '0x' + newAddress;
                }

                if (newAddress.length !== 42) {
                    showMessage('error', 'Ïò¨Î∞îÎ•∏ EVM Ï£ºÏÜå ÌòïÏãùÏù¥ ÏïÑÎãôÎãàÎã§. (42ÏûêÎ¶¨ ÌïÑÏöî)');
                    return;
                }

                try {
                    const web3Temp = new Web3();
                    newAddress = web3Temp.utils.toChecksumAddress(newAddress);
                } catch (e) {
                    showMessage('error', 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ EVM Ï£ºÏÜåÏûÖÎãàÎã§.');
                    return;
                }

                const existingWallet = findWalletByAddressEVM(newAddress);
                if (existingWallet && existingWallet.name !== editingWallet) {
                    showMessage('error', 'Ïù¥ÎØ∏ Îì±Î°ùÎêú Ï£ºÏÜåÏûÖÎãàÎã§! (EVM - ' + existingWallet.name + ')');
                    return;
                }

                if (wallets.EVM[newName] && newName !== editingWallet) {
                    showMessage('error', 'EVMÏóê Ïù¥ÎØ∏ ' + newName + ' Ïù¥Î¶ÑÏù¥ Ï°¥Ïû¨Ìï©ÎãàÎã§.');
                    return;
                }

                if (newName !== editingWallet) {
                    delete wallets.EVM[editingWallet];
                }

                wallets.EVM[newName] = { address: newAddress, region: newRegion };

            } else if (editingChainType === 'SOL') {
                if (newAddress.length < 32 || newAddress.length > 44) {
                    showMessage('error', 'Ïò¨Î∞îÎ•∏ SOL Ï£ºÏÜå ÌòïÏãùÏù¥ ÏïÑÎãôÎãàÎã§. (32-44Ïûê)');
                    return;
                }

                try {
                    new solanaWeb3.PublicKey(newAddress);
                } catch (e) {
                    showMessage('error', 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ SOL Ï£ºÏÜåÏûÖÎãàÎã§.');
                    return;
                }

                // Ï§ëÎ≥µ Ï£ºÏÜå Ï≤¥ÌÅ¨
                for (const [existingName, walletData] of Object.entries(wallets.SOL || {})) {
                    const existingAddr = typeof walletData === 'object' ? walletData.address : walletData;
                    if (existingAddr === newAddress && existingName !== editingWallet) {
                        showMessage('error', 'Ïù¥ÎØ∏ Îì±Î°ùÎêú Ï£ºÏÜåÏûÖÎãàÎã§! (SOL - ' + existingName + ')');
                        return;
                    }
                }

                if (wallets.SOL[newName] && newName !== editingWallet) {
                    showMessage('error', 'SOLÏóê Ïù¥ÎØ∏ ' + newName + ' Ïù¥Î¶ÑÏù¥ Ï°¥Ïû¨Ìï©ÎãàÎã§.');
                    return;
                }

                if (newName !== editingWallet) {
                    delete wallets.SOL[editingWallet];
                }

                wallets.SOL[newName] = { address: newAddress, region: newRegion };
            }

            const saved = await saveWallets();
            if (saved) {
                showMessage('success', editingChainType + ' - ' + newName + ' ÏßÄÍ∞ëÏù¥ ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§! (' + (newRegion === 'DOMESTIC' ? 'Íµ≠ÎÇ¥' : 'Ìï¥Ïô∏') + ')');
            } else {
                showMessage('warning', 'ÏßÄÍ∞ëÏùÄ ÏàòÏ†ïÎêòÏóàÏßÄÎßå ÌÅ¥ÎùºÏö∞Îìú ÎèôÍ∏∞ÌôîÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
            }

            displayWallets();
            cancelEdit();
            checkForArrayAddresses();
        }

        async function addWallet() {
            const chainType = document.getElementById('walletChainType').value;
            const name = document.getElementById('walletName').value.trim();
            let address = document.getElementById('walletAddress').value.trim();

            if (!name || !address) {
                showMessage('error', 'Í±∞ÎûòÏÜåÎ™ÖÍ≥º Ï£ºÏÜåÎ•º Î™®Îëê ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
                return;
            }

            if (chainType === 'EVM') {
                if (!address.startsWith('0x')) {
                    address = '0x' + address;
                }

                if (address.length !== 42) {
                    showMessage('error', 'Ïò¨Î∞îÎ•∏ EVM Ï£ºÏÜå ÌòïÏãùÏù¥ ÏïÑÎãôÎãàÎã§. (42ÏûêÎ¶¨ ÌïÑÏöî)');
                    return;
                }

                try {
                    const web3Temp = new Web3();
                    address = web3Temp.utils.toChecksumAddress(address);
                } catch (e) {
                    showMessage('error', 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ EVM Ï£ºÏÜåÏûÖÎãàÎã§.');
                    return;
                }

                if (!wallets.EVM) wallets.EVM = {};

                const existingWallet = findWalletByAddressEVM(address);
                if (existingWallet) {
                    showMessage('error', 'Ïù¥ÎØ∏ Îì±Î°ùÎêú Ï£ºÏÜåÏûÖÎãàÎã§! (EVM - ' + existingWallet.name + ')');
                    return;
                }

                if (wallets.EVM[name]) {
                    showMessage('error', 'EVMÏóê Ïù¥ÎØ∏ ' + name + ' Ïù¥Î¶ÑÏù¥ Ï°¥Ïû¨Ìï©ÎãàÎã§.');
                    return;
                }

                const region = document.getElementById('walletRegion').value;
                wallets.EVM[name] = { address: address, region: region };

                const saved = await saveWallets();
                if (saved) {
                    showMessage('success', 'EVM - ' + name + ' ÏßÄÍ∞ëÏù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§! (' + (region === 'DOMESTIC' ? 'Íµ≠ÎÇ¥' : 'Ìï¥Ïô∏') + ')');
                } else {
                    showMessage('warning', 'ÏßÄÍ∞ëÏùÄ Ï∂îÍ∞ÄÎêòÏóàÏßÄÎßå ÌÅ¥ÎùºÏö∞Îìú ÎèôÍ∏∞ÌôîÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
                }

            } else if (chainType === 'SOL') {
                // SOL Ï£ºÏÜå Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨ (Base58, 32-44Ïûê)
                if (address.length < 32 || address.length > 44) {
                    showMessage('error', 'Ïò¨Î∞îÎ•∏ SOL Ï£ºÏÜå ÌòïÏãùÏù¥ ÏïÑÎãôÎãàÎã§. (32-44Ïûê)');
                    return;
                }

                try {
                    new solanaWeb3.PublicKey(address);
                } catch (e) {
                    showMessage('error', 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ SOL Ï£ºÏÜåÏûÖÎãàÎã§.');
                    return;
                }

                if (!wallets.SOL) wallets.SOL = {};

                // Ï§ëÎ≥µ Ï£ºÏÜå Ï≤¥ÌÅ¨
                for (const [existingName, walletData] of Object.entries(wallets.SOL)) {
                    const existingAddr = typeof walletData === 'object' ? walletData.address : walletData;
                    if (existingAddr === address) {
                        showMessage('error', 'Ïù¥ÎØ∏ Îì±Î°ùÎêú Ï£ºÏÜåÏûÖÎãàÎã§! (SOL - ' + existingName + ')');
                        return;
                    }
                }

                if (wallets.SOL[name]) {
                    showMessage('error', 'SOLÏóê Ïù¥ÎØ∏ ' + name + ' Ïù¥Î¶ÑÏù¥ Ï°¥Ïû¨Ìï©ÎãàÎã§.');
                    return;
                }

                const region = document.getElementById('walletRegion').value;
                wallets.SOL[name] = { address: address, region: region };

                const saved = await saveWallets();
                if (saved) {
                    showMessage('success', 'SOL - ' + name + ' ÏßÄÍ∞ëÏù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§! (' + (region === 'DOMESTIC' ? 'Íµ≠ÎÇ¥' : 'Ìï¥Ïô∏') + ')');
                } else {
                    showMessage('warning', 'ÏßÄÍ∞ëÏùÄ Ï∂îÍ∞ÄÎêòÏóàÏßÄÎßå ÌÅ¥ÎùºÏö∞Îìú ÎèôÍ∏∞ÌôîÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
                }
            }

            displayWallets();

            document.getElementById('walletName').value = '';
            document.getElementById('walletAddress').value = '';
            document.getElementById('walletRegion').value = 'FOREIGN';
        }

        async function deleteWallet(name, chainType = 'EVM') {
            if (confirm(chainType + ' - ' + name + ' ÏßÄÍ∞ëÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) {
                if (chainType === 'SOL') {
                    delete wallets.SOL[name];
                } else {
                    delete wallets.EVM[name];
                }

                const saved = await saveWallets();
                if (saved) {
                    showMessage('success', chainType + ' - ' + name + ' ÏßÄÍ∞ëÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§!');
                } else {
                    showMessage('warning', 'ÏßÄÍ∞ëÏùÄ ÏÇ≠Ï†úÎêòÏóàÏßÄÎßå ÌÅ¥ÎùºÏö∞Îìú ÎèôÍ∏∞ÌôîÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
                }

                displayWallets();
                checkForArrayAddresses();

                if (editingWallet === name) {
                    cancelEdit();
                }
            }
        }

        function toggleWalletManager() {
            const content = document.getElementById('walletManagerContent');
            const icon = document.getElementById('walletToggleIcon');

            content.classList.toggle('collapsed');
            icon.classList.toggle('collapsed');
        }

        function toggleCSVUpload() {
            const content = document.getElementById('csvUploadContent');
            const icon = document.getElementById('csvToggleIcon');

            if (content.style.maxHeight === '0px' || !content.style.maxHeight) {
                content.style.maxHeight = '200px';
                icon.textContent = 'üìÇ';
                icon.style.transform = 'rotate(0deg)';
            } else {
                content.style.maxHeight = '0px';
                icon.textContent = 'üìÅ';
                icon.style.transform = 'rotate(-90deg)';
            }
        }

        function downloadTemplate() {
            const csvContent = `name,address,region
Binance_Hot1,0x0000000000000000000000000000000000000001,FOREIGN
OKX_Hot1,0x0000000000000000000000000000000000000002,FOREIGN
Upbit_Hot1,0x0000000000000000000000000000000000000003,DOMESTIC
Bithumb_Hot1,0x0000000000000000000000000000000000000004,DOMESTIC`;

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', 'evm_wallets_template.csv');
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);

            showMessage('success', 'EVM ÏßÄÍ∞ë ÌÖúÌîåÎ¶øÏù¥ Îã§Ïö¥Î°úÎìúÎêòÏóàÏäµÎãàÎã§!');
        }

        async function uploadCSV() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];

            if (!file) {
                showMessage('error', 'CSV ÌååÏùºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.');
                return;
            }

            const isCSV = file.name.endsWith('.csv');
            const isXLSX = file.name.endsWith('.xlsx');

            if (!isCSV && !isXLSX) {
                showMessage('error', 'CSV ÎòêÎäî XLSX ÌååÏùºÎßå ÏóÖÎ°úÎìú Í∞ÄÎä•Ìï©ÎãàÎã§.');
                return;
            }

            try {
                document.getElementById('uploadStatus').innerHTML = '<span style="color: #ff9800;">üì§ ÌååÏùº Ï≤òÎ¶¨ Ï§ë...</span>';

                let lines = [];

                if (isXLSX) {
                    // XLSX ÌååÏùº Ï≤òÎ¶¨
                    const data = await file.arrayBuffer();
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const sheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1 });
                    lines = jsonData.map(row => row.join(','));
                    console.log(`üìä XLSX ÌååÏùº Î°úÎìú: ${sheetName} ÏãúÌä∏, ${lines.length}Ìñâ`);
                } else {
                    // CSV ÌååÏùº Ï≤òÎ¶¨
                    const text = await file.text();
                    lines = text.split('\n').filter(line => line.trim());
                }

                // Îπà Ï§Ñ Ï†úÍ±∞
                lines = lines.filter(line => line && line.trim());

                if (lines.length < 2) {
                    throw new Error('ÌååÏùºÏóê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
                }

                const headers = lines[0].toLowerCase().split(',').map(h => h.trim());
                const expectedHeaders = ['name', 'address', 'region', 'chain'];

                if (!expectedHeaders.every(header => headers.includes(header))) {
                    throw new Error('CSV Ìó§ÎçîÍ∞Ä Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§. name,address,region,chain ÌòïÏãùÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.');
                }

                let addedCount = 0;
                let addedEVM = 0;
                let addedSOL = 0;
                let errorCount = 0;
                let skippedCount = 0;
                const errors = [];
                const errorDetails = [];
                const skippedDuplicates = [];
                const batchSize = 50;
                const totalLines = lines.length - 1;

                // Ïù¥Î¶Ñ Ïπ¥Ïö¥ÌÑ∞: CSV Ï†ÑÏ≤¥ÏóêÏÑú ÏàúÏÑúÎåÄÎ°ú (1), (2), (3) Î∂ôÏù¥Í∏∞
                const nameCounterEVM = {};
                const nameCounterSOL = {};

                console.log(`üìä CSV Ï≤òÎ¶¨ ÏãúÏûë: ${totalLines}Í∞ú ÎùºÏù∏ÏùÑ ${batchSize}Í∞úÏî© Î∞∞Ïπò Ï≤òÎ¶¨`);

                const replaceMode = document.getElementById('replaceMode').checked;
                console.log(`üîÑ Î™®Îìú: ${replaceMode ? 'Ï†ÑÏ≤¥ ÍµêÏ≤¥' : 'Ï∂îÍ∞ÄÎßå'}`);

                // Ï†ÑÏ≤¥ ÍµêÏ≤¥ Î™®ÎìúÎ©¥ Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÏÇ≠Ï†ú
                if (replaceMode) {
                    wallets.EVM = {};
                    wallets.SOL = {};
                    console.log('üóëÔ∏è Í∏∞Ï°¥ EVM Î∞è SOL ÏßÄÍ∞ë Ï†ÑÏ≤¥ ÏÇ≠Ï†ú');
                }

                // 1Îã®Í≥Ñ: CSV Ï†ÑÏ≤¥ Ïä§Ï∫î - Í∞Å Ïù¥Î¶ÑÏùò Îì±Ïû• ÏàúÏÑú ÎØ∏Î¶¨ Í≥ÑÏÇ∞
                console.log('üìã 1Îã®Í≥Ñ: CSV Ï†ÑÏ≤¥ Ïä§Ï∫î Ï§ë...');
                const nameOccurrenceMap = {};  // { "ÎùºÏù∏Î≤àÌò∏": { name: "OKX_Hot", chain: "EVM", occurrenceNum: 2 } }

                for (let i = 1; i < lines.length; i++) {
                    const line = lines[i];
                    const values = line.split(',').map(v => v.trim());
                    if (values.length < 4) continue;

                    const name = values[headers.indexOf('name')];
                    const chainValue = values[headers.indexOf('chain')] ? values[headers.indexOf('chain')].toUpperCase().trim() : '';
                    let chain = chainValue === 'NON-EVM' ? 'SOL' : chainValue;  // ÏùºÎã® non-EVMÏùÄ SOLÎ°ú Í∞ÄÏ†ï

                    if (!name || !chain) continue;

                    const key = `${chain}:${name}`;
                    if (!nameCounterEVM[key]) {
                        nameCounterEVM[key] = 0;
                    }
                    nameCounterEVM[key]++;

                    nameOccurrenceMap[i] = {
                        name: name,
                        chain: chain,
                        occurrenceNum: nameCounterEVM[key]
                    };
                }

                console.log(`‚úÖ Ïä§Ï∫î ÏôÑÎ£å: ${Object.keys(nameOccurrenceMap).length}Í∞ú ÎùºÏù∏ Î∂ÑÏÑù`);

                // Ïπ¥Ïö¥ÌÑ∞ Ï¥àÍ∏∞Ìôî (Ïã§Ï†ú Ï≤òÎ¶¨ÏóêÏÑú Îã§Ïãú ÏÇ¨Ïö©)
                for (const key in nameCounterEVM) {
                    nameCounterEVM[key] = 0;
                }

                for (let i = 1; i < lines.length; i += batchSize) {
                    const batchEnd = Math.min(i + batchSize, lines.length);
                    const batchLines = lines.slice(i, batchEnd);

                    console.log(`üîÑ Î∞∞Ïπò ${Math.ceil(i/batchSize)}/${Math.ceil(totalLines/batchSize)} Ï≤òÎ¶¨ Ï§ë... (${i}~${batchEnd-1})`);

                    const progress = Math.round((i / totalLines) * 100);
                    document.getElementById('uploadStatus').innerHTML =
                        `<span style="color: #ff9800;">üì§ ÌååÏùº Ï≤òÎ¶¨ Ï§ë... ${progress}% (${i}/${totalLines})</span>`;

                    const batchPromises = batchLines.map(async (line, index) => {
                        const lineNumber = i + index;
                        try {
                            const values = line.split(',').map(v => v.trim());

                            if (values.length < 4) return { success: false, line: lineNumber, error: 'Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°± (name,address,region,chain ÌïÑÏöî)' };

                            const nameIndex = headers.indexOf('name');
                            const addressIndex = headers.indexOf('address');
                            const regionIndex = headers.indexOf('region');
                            const chainIndex = headers.indexOf('chain');

                            const name = values[nameIndex];
                            let address = values[addressIndex];
                            const region = values[regionIndex] ? values[regionIndex].toUpperCase().trim() : 'FOREIGN';
                            const chain = values[chainIndex] ? values[chainIndex].toUpperCase().trim() : '';

                            if (region !== 'FOREIGN' && region !== 'DOMESTIC') {
                                return { success: false, line: lineNumber, error: 'regionÏùÄ FOREIGN ÎòêÎäî DOMESTICÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.' };
                            }

                            if (!name) {
                                return { success: false, line: lineNumber, error: 'Í±∞ÎûòÏÜåÎ™ÖÏù¥ ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.' };
                            }

                            if (!address) {
                                return { success: false, line: lineNumber, error: 'Ï£ºÏÜåÍ∞Ä ÎπÑÏñ¥ÏûàÏäµÎãàÎã§.' };
                            }

                            if (chain !== 'EVM' && chain !== 'SOL' && chain !== 'NON-EVM') {
                                return { success: false, line: lineNumber, error: 'chainÏùÄ EVM, SOL ÎòêÎäî non-EVMÏù¥Ïñ¥Ïïº Ìï©ÎãàÎã§.' };
                            }

                            // EVM Ï≤òÎ¶¨
                            if (chain === 'EVM') {
                                if (!address.startsWith('0x')) {
                                    return { success: false, line: lineNumber, error: 'EVM Ï£ºÏÜåÎäî 0xÎ°ú ÏãúÏûëÌï¥Ïïº Ìï©ÎãàÎã§.' };
                                }

                                try {
                                    const web3Temp = new Web3();
                                    address = web3Temp.utils.toChecksumAddress(address);
                                } catch (e) {
                                    return { success: false, line: lineNumber, error: 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ EVM Ï£ºÏÜå' };
                                }

                                if (!wallets.EVM) {
                                    wallets.EVM = {};
                                }

                                // Ï∂îÍ∞ÄÎßå Î™®ÎìúÏùº Îïå Ï§ëÎ≥µ Ï≤¥ÌÅ¨
                                if (!replaceMode) {
                                    const existingWallet = findWalletByAddressEVM(address);
                                    if (existingWallet) {
                                        return {
                                            success: false,
                                            skipped: true,
                                            line: lineNumber,
                                            address: address,
                                            name: name,
                                            chain: 'EVM',
                                            existingName: existingWallet.name,
                                            error: `Ï§ëÎ≥µ Ï£ºÏÜå Ïä§ÌÇµ (Í∏∞Ï°¥: ${existingWallet.name})`
                                        };
                                    }

                                    // ÎØ∏Î¶¨ Í≥ÑÏÇ∞Îêú Îì±Ïû• ÏàúÏÑú ÏÇ¨Ïö©
                                    const occurrence = nameOccurrenceMap[lineNumber];
                                    let finalName = name;

                                    if (occurrence && occurrence.occurrenceNum > 1) {
                                        // 2Î≤àÏß∏ Ïù¥ÏÉÅ Îì±Ïû•
                                        finalName = `${name}(${occurrence.occurrenceNum})`;
                                    } else if (wallets.EVM[name]) {
                                        // Ï≤´ Î≤àÏß∏ Îì±Ïû•Ïù∏Îç∞ DBÏóê Ïù¥ÎØ∏ ÏûàÏùå
                                        finalName = `${name}(1)`;
                                    }

                                    // DBÏóê Ïù¥ÎØ∏ ÏûàÎäîÏßÄ Îã§Ïãú Ï≤¥ÌÅ¨
                                    let counter = occurrence ? occurrence.occurrenceNum : 1;
                                    while (wallets.EVM[finalName]) {
                                        counter++;
                                        finalName = `${name}(${counter})`;
                                    }

                                    if (finalName !== name) {
                                        console.log(`üîÑ EVM Ï§ëÎ≥µ Ïù¥Î¶Ñ Ï≤òÎ¶¨: ${name} ‚Üí ${finalName}`);
                                    }

                                    return { success: true, chain: 'EVM', name: finalName, address, region, isDuplicate: finalName !== name };
                                }

                                return { success: true, chain: 'EVM', name, address, region };
                            }

                            // SOL Ï≤òÎ¶¨
                            if (chain === 'SOL') {
                                if (address.length < 32 || address.length > 44) {
                                    return { success: false, line: lineNumber, error: 'SOL Ï£ºÏÜåÎäî 32-44ÏûêÏó¨Ïïº Ìï©ÎãàÎã§.' };
                                }

                                try {
                                    new solanaWeb3.PublicKey(address);
                                } catch (e) {
                                    return { success: false, line: lineNumber, error: 'Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ SOL Ï£ºÏÜå' };
                                }

                                if (!wallets.SOL) {
                                    wallets.SOL = {};
                                }

                                // Ï∂îÍ∞ÄÎßå Î™®ÎìúÏùº Îïå Ï§ëÎ≥µ Ï≤¥ÌÅ¨
                                if (!replaceMode) {
                                    // SOL Ï§ëÎ≥µ Ï£ºÏÜå Ï≤¥ÌÅ¨
                                    let existingWallet = null;
                                    if (wallets.SOL) {
                                        for (const [existingName, walletData] of Object.entries(wallets.SOL)) {
                                            const existingAddr = typeof walletData === 'object' ? walletData.address : walletData;
                                            if (existingAddr === address) {
                                                existingWallet = { name: existingName };
                                                break;
                                            }
                                        }
                                    }

                                    if (existingWallet) {
                                        return {
                                            success: false,
                                            skipped: true,
                                            line: lineNumber,
                                            address: address,
                                            name: name,
                                            chain: 'SOL',
                                            existingName: existingWallet.name,
                                            error: `Ï§ëÎ≥µ Ï£ºÏÜå Ïä§ÌÇµ (Í∏∞Ï°¥: ${existingWallet.name})`
                                        };
                                    }

                                    // ÎØ∏Î¶¨ Í≥ÑÏÇ∞Îêú Îì±Ïû• ÏàúÏÑú ÏÇ¨Ïö©
                                    const occurrence = nameOccurrenceMap[lineNumber];
                                    let finalName = name;

                                    if (occurrence && occurrence.occurrenceNum > 1) {
                                        // 2Î≤àÏß∏ Ïù¥ÏÉÅ Îì±Ïû•
                                        finalName = `${name}(${occurrence.occurrenceNum})`;
                                    } else if (wallets.SOL[name]) {
                                        // Ï≤´ Î≤àÏß∏ Îì±Ïû•Ïù∏Îç∞ DBÏóê Ïù¥ÎØ∏ ÏûàÏùå
                                        finalName = `${name}(1)`;
                                    }

                                    // DBÏóê Ïù¥ÎØ∏ ÏûàÎäîÏßÄ Îã§Ïãú Ï≤¥ÌÅ¨
                                    let counter = occurrence ? occurrence.occurrenceNum : 1;
                                    while (wallets.SOL[finalName]) {
                                        counter++;
                                        finalName = `${name}(${counter})`;
                                    }

                                    if (finalName !== name) {
                                        console.log(`üîÑ SOL Ï§ëÎ≥µ Ïù¥Î¶Ñ Ï≤òÎ¶¨: ${name} ‚Üí ${finalName}`);
                                    }

                                    return { success: true, chain: 'SOL', name: finalName, address, region, isDuplicate: finalName !== name };
                                }

                                return { success: true, chain: 'SOL', name, address, region };
                            }

                            // non-EVM ÏûêÎèô Í∞êÏßÄ
                            if (chain === 'NON-EVM') {
                                // 1. Solana Í≤ÄÏ¶ù ÏãúÎèÑ
                                if (address.length >= 32 && address.length <= 44) {
                                    try {
                                        new solanaWeb3.PublicKey(address);
                                        console.log(`üîç non-EVM ÏûêÎèô Í∞êÏßÄ: ${name} ‚Üí SOL`);

                                        if (!wallets.SOL) {
                                            wallets.SOL = {};
                                        }

                                        // Ï∂îÍ∞ÄÎßå Î™®ÎìúÏùº Îïå Ï§ëÎ≥µ Ï≤¥ÌÅ¨
                                        if (!replaceMode) {
                                            // SOL Ï§ëÎ≥µ Ï£ºÏÜå Ï≤¥ÌÅ¨
                                            let existingWallet = null;
                                            if (wallets.SOL) {
                                                for (const [existingName, walletData] of Object.entries(wallets.SOL)) {
                                                    const existingAddr = typeof walletData === 'object' ? walletData.address : walletData;
                                                    if (existingAddr === address) {
                                                        existingWallet = { name: existingName };
                                                        break;
                                                    }
                                                }
                                            }

                                            if (existingWallet) {
                                                return {
                                                    success: false,
                                                    skipped: true,
                                                    line: lineNumber,
                                                    address: address,
                                                    name: name,
                                                    chain: 'SOL',
                                                    existingName: existingWallet.name,
                                                    error: `Ï§ëÎ≥µ Ï£ºÏÜå Ïä§ÌÇµ (Í∏∞Ï°¥: ${existingWallet.name})`
                                                };
                                            }

                                            // ÎØ∏Î¶¨ Í≥ÑÏÇ∞Îêú Îì±Ïû• ÏàúÏÑú ÏÇ¨Ïö©
                                            const occurrence = nameOccurrenceMap[lineNumber];
                                            let finalName = name;

                                            if (occurrence && occurrence.occurrenceNum > 1) {
                                                // 2Î≤àÏß∏ Ïù¥ÏÉÅ Îì±Ïû•
                                                finalName = `${name}(${occurrence.occurrenceNum})`;
                                            } else if (wallets.SOL[name]) {
                                                // Ï≤´ Î≤àÏß∏ Îì±Ïû•Ïù∏Îç∞ DBÏóê Ïù¥ÎØ∏ ÏûàÏùå
                                                finalName = `${name}(1)`;
                                            }

                                            // DBÏóê Ïù¥ÎØ∏ ÏûàÎäîÏßÄ Îã§Ïãú Ï≤¥ÌÅ¨
                                            let counter = occurrence ? occurrence.occurrenceNum : 1;
                                            while (wallets.SOL[finalName]) {
                                                counter++;
                                                finalName = `${name}(${counter})`;
                                            }

                                            if (finalName !== name) {
                                                console.log(`üîÑ SOL Ï§ëÎ≥µ Ïù¥Î¶Ñ Ï≤òÎ¶¨: ${name} ‚Üí ${finalName}`);
                                            }

                                            return { success: true, chain: 'SOL', name: finalName, address, region, isDuplicate: finalName !== name };
                                        }

                                        return { success: true, chain: 'SOL', name, address, region };
                                    } catch (e) {
                                        // Solana ÏïÑÎãò
                                    }
                                }

                                // 2. Îã§Î•∏ Ï≤¥Ïù∏ Í∞êÏßÄ (Ìñ•ÌõÑ Ï∂îÍ∞Ä Í∞ÄÎä•)
                                // TODO: TRX (starts with T), BTC (starts with 1, 3, bc1) Îì±

                                return { success: false, line: lineNumber, error: 'non-EVM Ï£ºÏÜå ÌòïÏãùÏùÑ Í∞êÏßÄÌï† Ïàò ÏóÜÏäµÎãàÎã§. (ÌòÑÏû¨ SOLÎßå ÏßÄÏõê)' };
                            }

                        } catch (error) {
                            return { success: false, line: lineNumber, error: error.message };
                        }
                    });

                    const batchResults = await Promise.all(batchPromises);

                    let updatedCount = 0;
                    let duplicateCount = 0;

                    batchResults.forEach((result, index) => {
                        if (result.success) {
                            if (result.chain === 'EVM') {
                                wallets.EVM[result.name] = { address: result.address, region: result.region };
                                addedEVM++;
                            } else if (result.chain === 'SOL') {
                                wallets.SOL[result.name] = { address: result.address, region: result.region };
                                addedSOL++;
                            }
                            addedCount++;

                            if (result.isUpdate) {
                                updatedCount++;
                            }

                            if (result.isDuplicate) {
                                duplicateCount++;
                            }
                        } else if (result.skipped) {
                            // Ï§ëÎ≥µ Ï£ºÏÜåÎ°ú Ïä§ÌÇµÎêú Í≤ΩÏö∞
                            skippedDuplicates.push({
                                line: result.line + 1,
                                name: result.name,
                                address: result.address,
                                chain: result.chain,
                                existingName: result.existingName
                            });
                            skippedCount++;
                        } else {
                            // Ïã§Ï†ú ÏóêÎü¨
                            errors.push(`Ï§Ñ ${result.line + 1}: ${result.error}`);

                            // ÏÉÅÏÑ∏ ÏóêÎü¨ Ï†ïÎ≥¥ ÏàòÏßë
                            const failedLine = lines[result.line];
                            const failedValues = failedLine.split(',').map(v => v.trim());
                            const failedName = failedValues[headers.indexOf('name')] || '(Ïù¥Î¶Ñ ÏóÜÏùå)';
                            const failedAddress = failedValues[headers.indexOf('address')] || '(Ï£ºÏÜå ÏóÜÏùå)';

                            errorDetails.push({
                                line: result.line + 1,
                                name: failedName,
                                address: failedAddress,
                                error: result.error
                            });
                            errorCount++;
                        }
                    });

                    if (updatedCount > 0) {
                        console.log(`üîÑ ${updatedCount}Í∞ú ÏßÄÍ∞ë Ï£ºÏÜå ÏóÖÎç∞Ïù¥Ìä∏Îê®`);
                    }

                    if (duplicateCount > 0) {
                        console.log(`üìù ${duplicateCount}Í∞ú ÏßÄÍ∞ë Ïù¥Î¶Ñ ÏûêÎèô Î≥ÄÍ≤ΩÎê® (Ï§ëÎ≥µ Ï≤òÎ¶¨)`);
                    }

                    if (i + batchSize < lines.length) {
                        await new Promise(resolve => setTimeout(resolve, 10));
                    }
                }

                if (addedCount > 0 || skippedCount > 0) {
                    console.log(`‚úÖ CSV Ï≤òÎ¶¨ ÏôÑÎ£å: ${addedCount}Í∞ú ÏÑ±Í≥µ (EVM ${addedEVM}Í∞ú, SOL ${addedSOL}Í∞ú), ${errorCount}Í∞ú Ïã§Ìå®, ${skippedCount}Í∞ú Ï§ëÎ≥µ Ïä§ÌÇµ`);

                    // Ï§ëÎ≥µ Ï£ºÏÜå ÏÉÅÏÑ∏ Î°úÍ∑∏ Ï∂úÎ†•
                    if (skippedDuplicates.length > 0) {
                        console.log(`\n‚ö†Ô∏è  ========================================`);
                        console.log(`‚ö†Ô∏è  Ï§ëÎ≥µ Ï£ºÏÜå Î∞úÍ≤¨: ${skippedDuplicates.length}Í∞ú`);
                        console.log(`‚ö†Ô∏è  ========================================`);
                        console.log(`\nüìã CSVÎ•º ÏàòÏ†ïÌïú ÌõÑ Îã§Ïãú ÏóÖÎ°úÎìúÌïòÏÑ∏Ïöî:\n`);

                        skippedDuplicates.forEach((dup, idx) => {
                            console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);
                            console.log(`[${idx + 1}/${skippedDuplicates.length}] CSV Ï§Ñ Î≤àÌò∏: ${dup.line}`);
                            console.log(`   üîó Ï≤¥Ïù∏: ${dup.chain}`);
                            console.log(`   ‚ùå CSVÏóêÏÑú Ï∂îÍ∞ÄÌïòÎ†§Îäî Ïù¥Î¶Ñ: "${dup.name}"`);
                            console.log(`   ‚úÖ DBÏóê Ïù¥ÎØ∏ ÏûàÎäî Ïù¥Î¶Ñ: "${dup.existingName}"`);
                            console.log(`   üìç Ï§ëÎ≥µÎêú Ï£ºÏÜå (Ï†ÑÏ≤¥): ${dup.address}`);
                            console.log(`   üí° Ìï¥Í≤∞Î∞©Î≤ï: CSVÏóêÏÑú Ïù¥ Ï§ÑÏùÑ ÏÇ≠Ï†úÌïòÍ±∞ÎÇò, Îã§Î•∏ Ï£ºÏÜåÎ°ú Î≥ÄÍ≤ΩÌïòÏÑ∏Ïöî`);
                        });

                        console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);
                        console.log(`üìä ÏöîÏïΩ: ${skippedDuplicates.length}Í∞ú Ï§ëÎ≥µ Ï£ºÏÜå Ïä§ÌÇµÎê®`);
                        console.log(`‚úÖ ÏÑ±Í≥µ: ${addedCount}Í∞ú Ï∂îÍ∞ÄÎê®`);
                        console.log(`‚ùå Ïã§Ìå®: ${errorCount}Í∞ú Ïò§Î•ò\n`);
                    }

                    // ÏóêÎü¨ ÏÉÅÏÑ∏ Î°úÍ∑∏ Ï∂úÎ†•
                    if (errorDetails.length > 0) {
                        console.log(`\n‚ùå ========================================`);
                        console.log(`‚ùå Ïò§Î•ò Î∞úÏÉù: ${errorDetails.length}Í∞ú`);
                        console.log(`‚ùå ========================================`);
                        console.log(`\nüîç Ïò§Î•ò ÏÉÅÏÑ∏ ÎÇ¥Ïó≠:\n`);

                        errorDetails.forEach((err, idx) => {
                            console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`);
                            console.log(`[${idx + 1}/${errorDetails.length}] CSV Ï§Ñ Î≤àÌò∏: ${err.line}`);
                            console.log(`   üìù Ïù¥Î¶Ñ: "${err.name}"`);
                            console.log(`   üìç Ï£ºÏÜå: ${err.address}`);
                            console.log(`   ‚ùå Ïò§Î•ò: ${err.error}`);
                            console.log(`   üí° Ìï¥Í≤∞Î∞©Î≤ï: CSVÏóêÏÑú Ïù¥ Ï§ÑÏùÑ ÌôïÏù∏ÌïòÍ≥† ÏàòÏ†ïÌïòÏÑ∏Ïöî`);
                        });

                        console.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n`);
                        console.log(`üìä ÏöîÏïΩ: ${errorDetails.length}Í∞ú Ïò§Î•ò`);
                        console.log(`‚úÖ ÏÑ±Í≥µ: ${addedCount}Í∞ú Ï∂îÍ∞ÄÎê®\n`);
                    }

                    const saved = await saveWallets();
                    displayWallets();
                    checkForArrayAddresses();

                    // Ïã§Ï†ú Ï†ÄÏû•Îêú Í∞úÏàò ÌôïÏù∏
                    const actualEVM = Object.keys(wallets.EVM || {}).length;
                    const actualSOL = Object.keys(wallets.SOL || {}).length;
                    const actualTotal = actualEVM + actualSOL;

                    console.log(`\nüìä ========================================`);
                    console.log(`üìä Ï†ÄÏû• Í≤∞Í≥º ÎπÑÍµê`);
                    console.log(`üìä ========================================`);
                    console.log(`   Ï∂îÍ∞Ä ÏãúÎèÑ: EVM ${addedEVM}Í∞ú, SOL ${addedSOL}Í∞ú = Ï¥ù ${addedCount}Í∞ú`);
                    console.log(`   Ïã§Ï†ú Ï†ÄÏû•: EVM ${actualEVM}Í∞ú, SOL ${actualSOL}Í∞ú = Ï¥ù ${actualTotal}Í∞ú`);

                    const lostEVM = addedEVM - actualEVM;
                    const lostSOL = addedSOL - actualSOL;
                    const lostTotal = addedCount - actualTotal;

                    if (lostEVM !== 0 || lostSOL !== 0) {
                        console.warn(`   ‚ö†Ô∏è ÏÜêÏã§: EVM ${lostEVM}Í∞ú, SOL ${lostSOL}Í∞ú = Ï¥ù ${lostTotal}Í∞ú`);
                        console.warn(`   üí° Ï§ëÎ≥µ Ïù¥Î¶Ñ Ï≤òÎ¶¨ Ï§ë ÎçÆÏñ¥Ïì∞Í∏∞Í∞Ä Î∞úÏÉùÌñàÏùÑ Ïàò ÏûàÏäµÎãàÎã§!`);
                    } else {
                        console.log(`   ‚úÖ ÏÜêÏã§ ÏóÜÏùå: Î™®Îì† ÏßÄÍ∞ëÏù¥ Ï†ïÏÉÅ Ï†ÄÏû•Îê®`);
                    }
                    console.log(`üìä ========================================\n`);

                    let statusMessage = `‚úÖ ${actualTotal}Í∞ú ÏßÄÍ∞ëÏù¥ Ï†ÄÏû•ÎêòÏóàÏäµÎãàÎã§! (EVM ${actualEVM}Í∞ú, SOL ${actualSOL}Í∞ú)`;
                    if (lostTotal > 0) {
                        statusMessage += ` [‚ö†Ô∏è ${lostTotal}Í∞ú ÏÜêÏã§]`;
                    }
                    if (skippedCount > 0) {
                        statusMessage += ` (${skippedCount}Í∞ú Ï§ëÎ≥µ Ïä§ÌÇµ)`;
                    }
                    if (errorCount > 0) {
                        statusMessage += ` (${errorCount}Í∞ú Ïò§Î•ò)`;
                    }
                    if (!saved) {
                        statusMessage += ' (ÌÅ¥ÎùºÏö∞Îìú ÎèôÍ∏∞Ìôî Ïã§Ìå®)';
                    }

                    showMessage('success', statusMessage);

                    // UI ÏÉÅÌÉú Î©îÏãúÏßÄ Íµ¨ÏÑ±
                    let uploadStatusHTML = '';

                    // Ï§ëÎ≥µ Ï£ºÏÜå ÌëúÏãú (ÏµúÎåÄ 5Í∞ú)
                    if (skippedDuplicates.length > 0) {
                        uploadStatusHTML += '<span style="color: #FF9800; font-weight: bold;">‚ö†Ô∏è Ï§ëÎ≥µ Ï£ºÏÜå Î∞úÍ≤¨ (' + skippedDuplicates.length + 'Í∞ú)</span><br>';
                        uploadStatusHTML += '<span style="color: #FFC107; font-size: 10px;">‚Üí ÏΩòÏÜî(F12)ÏóêÏÑú Ï†ÑÏ≤¥ Î™©Î°ù ÌôïÏù∏ Í∞ÄÎä•</span><br><br>';
                        const displaySkipped = skippedDuplicates.slice(0, 5);
                        displaySkipped.forEach(dup => {
                            uploadStatusHTML += `<div style="background: #2a2a2a; padding: 8px; margin: 4px 0; border-left: 3px solid #FF9800; font-size: 11px;">`;
                            uploadStatusHTML += `<div style="color: #9C27B0; font-size: 10px; margin-bottom: 4px;">[${dup.chain}]</div>`;
                            uploadStatusHTML += `<div style="color: #FF5252;">‚ùå CSV: "${dup.name}" (Ï§Ñ ${dup.line})</div>`;
                            uploadStatusHTML += `<div style="color: #4CAF50;">‚úÖ DB: "${dup.existingName}"</div>`;
                            uploadStatusHTML += `<div style="color: #2196F3; font-size: 10px; margin-top: 4px;">Ï£ºÏÜå: ${dup.address.slice(0, 10)}...${dup.address.slice(-8)}</div>`;
                            uploadStatusHTML += `</div>`;
                        });
                        if (skippedDuplicates.length > 5) {
                            uploadStatusHTML += `<span style="font-size: 11px; color: #999;">...Ïô∏ ${skippedDuplicates.length - 5}Í∞ú (ÏΩòÏÜî ÌôïÏù∏)</span><br>`;
                        }
                        uploadStatusHTML += '<br>';
                    }

                    // Ïã§Ï†ú Ïò§Î•ò ÌëúÏãú (ÏµúÎåÄ 5Í∞ú)
                    if (errorDetails.length > 0) {
                        uploadStatusHTML += '<span style="color: #F44336; font-weight: bold;">‚ùå Ïò§Î•ò Î∞úÏÉù (' + errorDetails.length + 'Í∞ú)</span><br>';
                        uploadStatusHTML += '<span style="color: #FF5722; font-size: 10px;">‚Üí ÏΩòÏÜî(F12)ÏóêÏÑú Ï†ÑÏ≤¥ Î™©Î°ù ÌôïÏù∏ Í∞ÄÎä•</span><br><br>';
                        const displayErrors = errorDetails.slice(0, 5);
                        displayErrors.forEach(err => {
                            uploadStatusHTML += `<div style="background: #2a2a2a; padding: 8px; margin: 4px 0; border-left: 3px solid #F44336; font-size: 11px;">`;
                            uploadStatusHTML += `<div style="color: #FF5252;">üìù Ïù¥Î¶Ñ: "${err.name}" (Ï§Ñ ${err.line})</div>`;
                            uploadStatusHTML += `<div style="color: #2196F3; font-size: 10px; margin-top: 4px;">Ï£ºÏÜå: ${err.address.length > 20 ? err.address.slice(0, 10) + '...' + err.address.slice(-8) : err.address}</div>`;
                            uploadStatusHTML += `<div style="color: #FF9800; margin-top: 4px;">‚ùå ${err.error}</div>`;
                            uploadStatusHTML += `</div>`;
                        });
                        if (errorDetails.length > 5) {
                            uploadStatusHTML += `<span style="font-size: 11px; color: #999;">...Ïô∏ ${errorDetails.length - 5}Í∞ú (ÏΩòÏÜî ÌôïÏù∏)</span><br>`;
                        }
                    }

                    // Î™®Îëê ÏÑ±Í≥µÌïú Í≤ΩÏö∞
                    if (uploadStatusHTML === '') {
                        uploadStatusHTML = '<span style="color: #4CAF50;">‚úÖ ÏóÖÎ°úÎìú ÏôÑÎ£å! Î™®Îì† ÏßÄÍ∞ëÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§!</span>';
                    }

                    document.getElementById('uploadStatus').innerHTML = uploadStatusHTML;

                    setTimeout(() => {
                        document.getElementById('uploadStatus').innerHTML = '';
                    }, 8000);

                } else {
                    throw new Error('Ï∂îÍ∞ÄÎêú ÏßÄÍ∞ëÏù¥ ÏóÜÏäµÎãàÎã§. CSV ÌòïÏãùÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.');
                }

                fileInput.value = '';

            } catch (error) {
                showMessage('error', 'CSV ÏóÖÎ°úÎìú Ïã§Ìå®: ' + error.message);
                document.getElementById('uploadStatus').innerHTML = '<span style="color: #f44336;">‚ùå ÏóÖÎ°úÎìú Ïã§Ìå®: ' + error.message + '</span>';
            }
        }

        // ÌéòÏù¥ÏßÄ Î°úÎìú Ïãú Î™®Îì† Ï≤¥Ïù∏ RPC ÎØ∏Î¶¨ Ïó∞Í≤∞ (Î∞±Í∑∏ÎùºÏö¥Îìú)
        async function preconnectAllChains() {
            console.log('‚ö° RPC ÏÇ¨Ï†Ñ Ïó∞Í≤∞ ÏãúÏûë...');

            const chains = Object.keys(CHAIN_CONFIG);

            // Î™®Îì† Ï≤¥Ïù∏ Î≥ëÎ†¨Î°ú ÏÇ¨Ï†Ñ Ïó∞Í≤∞
            const preconnectPromises = chains.map(async (chain) => {
                const config = CHAIN_CONFIG[chain];

                if (config.isEVM === false) {
                    // SOL Ï≤¥Ïù∏
                    try {
                        const rpcTests = config.rpcs.map(async (rpcUrl) => {
                            try {
                                const conn = new solanaWeb3.Connection(rpcUrl, { commitment: 'confirmed' });
                                const start = Date.now();
                                await Promise.race([
                                    conn.getSlot(),
                                    new Promise((_, reject) => setTimeout(() => reject('timeout'), 1500))
                                ]);
                                return { connection: conn, url: rpcUrl, latency: Date.now() - start };
                            } catch (e) {
                                return null;
                            }
                        });

                        const results = (await Promise.all(rpcTests)).filter(r => r !== null).sort((a, b) => a.latency - b.latency);
                        if (results.length > 0) {
                            solConnectionCache.connections = results;
                            console.log(`‚úÖ SOL: ${results.length}Í∞ú RPC Ï§ÄÎπÑ (ÏµúÍ≥†ÏÜç ${results[0].latency}ms)`);
                        }
                    } catch (e) {}
                } else {
                    // EVM Ï≤¥Ïù∏
                    try {
                        const rpcTests = config.rpcs.slice(0, 8).map(async (rpcUrl) => {
                            try {
                                const testWeb3 = new Web3(rpcUrl);
                                const start = Date.now();
                                await Promise.race([
                                    testWeb3.eth.getBlockNumber(),
                                    new Promise((_, reject) => setTimeout(() => reject('timeout'), 1500))
                                ]);
                                return { rpcUrl, latency: Date.now() - start };
                            } catch (e) {
                                return null;
                            }
                        });

                        const results = (await Promise.all(rpcTests)).filter(r => r !== null).sort((a, b) => a.latency - b.latency);
                        if (results.length > 0) {
                            rpcCache[chain] = results[0].rpcUrl;
                            console.log(`‚úÖ ${chain}: ${results[0].rpcUrl.replace('https://', '').split('/')[0]} (${results[0].latency}ms)`);
                        }
                    } catch (e) {}
                }
            });

            await Promise.all(preconnectPromises);
            console.log('‚ö° RPC ÏÇ¨Ï†Ñ Ïó∞Í≤∞ ÏôÑÎ£å!');
        }

        window.onload = async function() {
            console.log('üî• ÏõîÎ†õ ÎåÄÏãúÎ≥¥Îìú ÏãúÏûë...');

            try {
                document.getElementById('searchBtn').onclick = searchToken;
                document.getElementById('walletActionBtn').onclick = addWallet;
                document.getElementById('walletCancelBtn').onclick = cancelEdit;

                const firebaseOk = await initializeFirebase();
                await loadWallets();

                // Enter ÌÇ§ ÏßÄÏõê
                document.getElementById('tokenInput').addEventListener('keypress', function(e) {
                    if (e.key === 'Enter' && !isSearching) {
                        searchToken();
                    }
                });

                // Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú RPC ÏÇ¨Ï†Ñ Ïó∞Í≤∞ (UI Ï∞®Îã® ÏïàÌï®)
                preconnectAllChains();

                console.log('‚úÖ ÎåÄÏãúÎ≥¥Îìú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å!');

            } catch (error) {
                console.error('‚ùå Ï¥àÍ∏∞Ìôî Ïò§Î•ò:', error);
                showMessage('error', 'ÏãúÏä§ÌÖú Ï¥àÍ∏∞ÌôîÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
            }
        };
    </script>

    <!-- Î°úÍ∑∏ Ìå®ÎÑê -->
    <div id="logPanel" class="log-panel minimized">
        <div class="log-header">
            <h3>üìã Ïã§ÏãúÍ∞Ñ Î°úÍ∑∏</h3>
            <div class="log-controls">
                <button class="log-btn" onclick="copyLogs()">Copy</button>
                <button class="log-btn" onclick="clearLogs()">Clear</button>
                <button class="log-btn" onclick="toggleLogPanel()">+</button>
            </div>
        </div>
        <div id="logContent" class="log-content"></div>
    </div>

    <script>
        // Î°úÍ∑∏ ÏãúÏä§ÌÖú
        const logContent = document.getElementById('logContent');
        const logPanel = document.getElementById('logPanel');
        const MAX_LOGS = 100;

        function addLog(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = 'log-entry';

            const time = new Date().toLocaleTimeString('ko-KR', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });

            let className = 'log-info';
            if (type === 'error' || message.includes('‚ùå') || message.includes('Ïã§Ìå®')) {
                className = 'log-error';
            } else if (type === 'warn' || message.includes('‚ö†Ô∏è')) {
                className = 'log-warn';
            } else if (message.includes('‚úÖ') || message.includes('ÏÑ±Í≥µ') || message.includes('ÏôÑÎ£å')) {
                className = 'log-success';
            } else if (message.includes('üîå') || message.includes('WebSocket') || message.includes('üì°')) {
                className = 'log-websocket';
            }

            entry.innerHTML = `<span class="log-time">${time}</span><span class="${className}">${message}</span>`;
            logContent.appendChild(entry);

            // ÏµúÎåÄ Î°úÍ∑∏ Ïàò Ï†úÌïú
            while (logContent.children.length > MAX_LOGS) {
                logContent.removeChild(logContent.firstChild);
            }

            // ÏûêÎèô Ïä§ÌÅ¨Î°§
            logContent.scrollTop = logContent.scrollHeight;
        }

        function copyLogs() {
            const logs = Array.from(logContent.children)
                .map(entry => entry.textContent)
                .join('\n');

            navigator.clipboard.writeText(logs).then(() => {
                const originalText = 'Copy';
                const btn = document.querySelector('.log-controls button:first-child');
                btn.textContent = '‚úì';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 1000);
            }).catch(err => {
                console.error('Î°úÍ∑∏ Î≥µÏÇ¨ Ïã§Ìå®:', err);
                alert('Î°úÍ∑∏ Î≥µÏÇ¨Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
            });
        }

        function clearLogs() {
            logContent.innerHTML = '';
            addLog('Î°úÍ∑∏Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.');
        }

        function toggleLogPanel() {
            logPanel.classList.toggle('minimized');
            const btn = document.querySelector('.log-controls button:last-child');
            btn.textContent = logPanel.classList.contains('minimized') ? '+' : '‚àí';
        }

        // console.log Ïò§Î≤ÑÎùºÏù¥Îìú
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;

        console.log = function(...args) {
            originalLog.apply(console, args);
            addLog(args.join(' '), 'info');
        };

        console.error = function(...args) {
            originalError.apply(console, args);
            addLog(args.join(' '), 'error');
        };

        console.warn = function(...args) {
            originalWarn.apply(console, args);
            addLog(args.join(' '), 'warn');
        };

        // Ï¥àÍ∏∞ Î°úÍ∑∏
        addLog('üöÄ Î°úÍ∑∏ ÏãúÏä§ÌÖú ÏãúÏûë');
    </script>
</body>
</html>
